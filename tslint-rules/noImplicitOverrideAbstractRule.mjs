/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Replacement } from 'tslint/lib';
import { TypedRule } from 'tslint/lib/rules';
import * as ts from 'typescript';
const FAILURE_MESSAGE = 'Missing override modifier. Members implemented as part of ' +
    'abstract classes must explicitly set the "override" modifier. ' +
    'More details: https://github.com/microsoft/TypeScript/issues/44457#issuecomment-856202843.';
/**
 * Rule which enforces that class members implementing abstract members
 * from base classes explicitly specify the `override` modifier.
 *
 * This ensures we follow the best-practice of applying `override` for abstract-implemented
 * members so that TypeScript creates diagnostics in both scenarios where either the abstract
 * class member is removed, or renamed.
 *
 * More details can be found here: https://github.com/microsoft/TypeScript/issues/44457.
 */
export class Rule extends TypedRule {
    applyWithProgram(sourceFile, program) {
        return this.applyWithFunction(sourceFile, ctx => visitNode(sourceFile, ctx, program));
    }
}
/**
 * For a TypeScript AST node and each of its child nodes, check whether the node is a class
 * element which implements an abstract member but does not have the `override` keyword.
 */
function visitNode(node, ctx, program) {
    // If a class element implements an abstract member but does not have the
    // `override` keyword, create a lint failure.
    if (ts.isClassElement(node) && !hasOverrideModifier(node) &&
        matchesParentAbstractElement(node, program)) {
        ctx.addFailureAtNode(node, FAILURE_MESSAGE, Replacement.appendText(node.getStart(), `override `));
    }
    ts.forEachChild(node, node => visitNode(node, ctx, program));
}
/**
 * Checks if the specified class element matches a parent abstract class element. i.e.
 * whether the specified member "implements" an abstract member from a base class.
 */
function matchesParentAbstractElement(node, program) {
    const containingClass = node.parent;
    // If the property we check does not have a property name, we cannot look for similarly-named
    // members in parent classes and therefore return early.
    if (node.name === undefined) {
        return false;
    }
    const propertyName = getPropertyNameText(node.name);
    const typeChecker = program.getTypeChecker();
    // If the property we check does not have a statically-analyzable property name,
    // we cannot look for similarly-named members in parent classes and return early.
    if (propertyName === null) {
        return false;
    }
    return checkClassForInheritedMatchingAbstractMember(containingClass, typeChecker, propertyName);
}
/** Checks if the given class inherits an abstract member with the specified name. */
function checkClassForInheritedMatchingAbstractMember(clazz, typeChecker, searchMemberName) {
    const baseClass = getBaseClass(clazz, typeChecker);
    // If the class is not `abstract`, then all parent abstract methods would need to
    // be implemented, and there is never an abstract member within the class.
    if (baseClass === null || !hasAbstractModifier(baseClass)) {
        return false;
    }
    const matchingMember = baseClass.members.find(m => m.name !== undefined && getPropertyNameText(m.name) === searchMemberName);
    if (matchingMember !== undefined) {
        return hasAbstractModifier(matchingMember);
    }
    return checkClassForInheritedMatchingAbstractMember(baseClass, typeChecker, searchMemberName);
}
/** Gets the base class for the given class declaration. */
function getBaseClass(node, typeChecker) {
    var _a, _b;
    const baseTypes = getExtendsHeritageExpressions(node);
    if (baseTypes.length > 1) {
        throw Error('Class unexpectedly extends from multiple types.');
    }
    const baseClass = typeChecker.getTypeAtLocation(baseTypes[0]).getSymbol();
    const baseClassDecl = (_a = baseClass === null || baseClass === void 0 ? void 0 : baseClass.valueDeclaration) !== null && _a !== void 0 ? _a : (_b = baseClass === null || baseClass === void 0 ? void 0 : baseClass.declarations) === null || _b === void 0 ? void 0 : _b[0];
    if (baseClassDecl !== undefined && ts.isClassDeclaration(baseClassDecl)) {
        return baseClassDecl;
    }
    return null;
}
/** Gets the `extends` base type expressions of the specified class. */
function getExtendsHeritageExpressions(classDecl) {
    if (classDecl.heritageClauses === undefined) {
        return [];
    }
    const result = [];
    for (const clause of classDecl.heritageClauses) {
        if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
            result.push(...clause.types);
        }
    }
    return result;
}
/** Gets whether the specified node has the `abstract` modifier applied. */
function hasAbstractModifier(node) {
    var _a;
    return !!((_a = node.modifiers) === null || _a === void 0 ? void 0 : _a.some(s => s.kind === ts.SyntaxKind.AbstractKeyword));
}
/** Gets whether the specified node has the `override` modifier applied. */
function hasOverrideModifier(node) {
    var _a;
    return !!((_a = node.modifiers) === null || _a === void 0 ? void 0 : _a.some(s => s.kind === ts.SyntaxKind.OverrideKeyword));
}
/** Gets the property name text of the specified property name. */
function getPropertyNameText(name) {
    if (ts.isComputedPropertyName(name)) {
        return null;
    }
    return name.text;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9JbXBsaWNpdE92ZXJyaWRlQWJzdHJhY3RSdWxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vZGV2LWluZnJhL3RzbGludC1ydWxlcy9ub0ltcGxpY2l0T3ZlcnJpZGVBYnN0cmFjdFJ1bGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HO0FBRUgsT0FBTyxFQUFDLFdBQVcsRUFBMkIsTUFBTSxZQUFZLENBQUM7QUFDakUsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBQzNDLE9BQU8sS0FBSyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBRWpDLE1BQU0sZUFBZSxHQUFHLDREQUE0RDtJQUNoRixnRUFBZ0U7SUFDaEUsNEZBQTRGLENBQUM7QUFFakc7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxPQUFPLElBQUssU0FBUSxTQUFTO0lBQ3hCLGdCQUFnQixDQUFDLFVBQXlCLEVBQUUsT0FBbUI7UUFDdEUsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUN4RixDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLFNBQVMsQ0FBQyxJQUFhLEVBQUUsR0FBZ0IsRUFBRSxPQUFtQjtJQUNyRSx5RUFBeUU7SUFDekUsNkNBQTZDO0lBQzdDLElBQUksRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQztRQUNyRCw0QkFBNEIsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLEVBQUU7UUFDL0MsR0FBRyxDQUFDLGdCQUFnQixDQUNoQixJQUFJLEVBQUUsZUFBZSxFQUFFLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENB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QUFDLGVBQWUsRUFBRTtRQUM5QyxJQUFJLE1BQU0sQ0FBQyxLQUFLLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxjQUFjLEVBQUU7WUFDakQsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM5QjtLQUNGO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQUVELDJFQUEyRTtBQUMzRSxTQUFTLG1CQUFtQixDQUFDLElBQWE7O0lBQ3hDLE9BQU8sQ0FBQyxDQUFDLENBQUEsTUFBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLENBQUEsQ0FBQztBQUMvRSxDQUFDO0FBRUQsMkVBQTJFO0FBQzNFLFNBQVMsbUJBQW1CLENBQUMsSUFBYTs7SUFDeEMsT0FBTyxDQUFDLENBQUMsQ0FBQSxNQUFBLElBQUksQ0FBQyxTQUFTLDBDQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQSxDQUFDO0FBQy9FLENBQUM7QUFFRCxrRUFBa0U7QUFDbEUsU0FBUyxtQkFBbUIsQ0FBQyxJQUFxQjtJQUNoRCxJQUFJLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNuQyxPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQ25CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtSZXBsYWNlbWVudCwgUnVsZUZhaWx1cmUsIFdhbGtDb250ZXh0fSBmcm9tICd0c2xpbnQvbGliJztcbmltcG9ydCB7VHlwZWRSdWxlfSBmcm9tICd0c2xpbnQvbGliL3J1bGVzJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5jb25zdCBGQUlMVVJFX01FU1NBR0UgPSAnTWlzc2luZyBvdmVycmlkZSBtb2RpZmllci4gTWVtYmVycyBpbXBsZW1lbnRlZCBhcyBwYXJ0IG9mICcgK1xuICAgICdhYnN0cmFjdCBjbGFzc2VzIG11c3QgZXhwbGljaXRseSBzZXQgdGhlIFwib3ZlcnJpZGVcIiBtb2RpZmllci4gJyArXG4gICAgJ01vcmUgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80NDQ1NyNpc3N1ZWNvbW1lbnQtODU2MjAyODQzLic7XG5cbi8qKlxuICogUnVsZSB3aGljaCBlbmZvcmNlcyB0aGF0IGNsYXNzIG1lbWJlcnMgaW1wbGVtZW50aW5nIGFic3RyYWN0IG1lbWJlcnNcbiAqIGZyb20gYmFzZSBjbGFzc2VzIGV4cGxpY2l0bHkgc3BlY2lmeSB0aGUgYG92ZXJyaWRlYCBtb2RpZmllci5cbiAqXG4gKiBUaGlzIGVuc3VyZXMgd2UgZm9sbG93IHRoZSBiZXN0LXByYWN0aWNlIG9mIGFwcGx5aW5nIGBvdmVycmlkZWAgZm9yIGFic3RyYWN0LWltcGxlbWVudGVkXG4gKiBtZW1iZXJzIHNvIHRoYXQgVHlwZVNjcmlwdCBjcmVhdGVzIGRpYWdub3N0aWNzIGluIGJvdGggc2NlbmFyaW9zIHdoZXJlIGVpdGhlciB0aGUgYWJzdHJhY3RcbiAqIGNsYXNzIG1lbWJlciBpcyByZW1vdmVkLCBvciByZW5hbWVkLlxuICpcbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80NDQ1Ny5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bGUgZXh0ZW5kcyBUeXBlZFJ1bGUge1xuICBvdmVycmlkZSBhcHBseVdpdGhQcm9ncmFtKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsIHByb2dyYW06IHRzLlByb2dyYW0pOiBSdWxlRmFpbHVyZVtdIHtcbiAgICByZXR1cm4gdGhpcy5hcHBseVdpdGhGdW5jdGlvbihzb3VyY2VGaWxlLCBjdHggPT4gdmlzaXROb2RlKHNvdXJjZUZpbGUsIGN0eCwgcHJvZ3JhbSkpO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGEgVHlwZVNjcmlwdCBBU1Qgbm9kZSBhbmQgZWFjaCBvZiBpdHMgY2hpbGQgbm9kZXMsIGNoZWNrIHdoZXRoZXIgdGhlIG5vZGUgaXMgYSBjbGFzc1xuICogZWxlbWVudCB3aGljaCBpbXBsZW1lbnRzIGFuIGFic3RyYWN0IG1lbWJlciBidXQgZG9lcyBub3QgaGF2ZSB0aGUgYG92ZXJyaWRlYCBrZXl3b3JkLlxuICovXG5mdW5jdGlvbiB2aXNpdE5vZGUobm9kZTogdHMuTm9kZSwgY3R4OiBXYWxrQ29udGV4dCwgcHJvZ3JhbTogdHMuUHJvZ3JhbSkge1xuICAvLyBJZiBhIGNsYXNzIGVsZW1lbnQgaW1wbGVtZW50cyBhbiBhYnN0cmFjdCBtZW1iZXIgYnV0IGRvZXMgbm90IGhhdmUgdGhlXG4gIC8vIGBvdmVycmlkZWAga2V5d29yZCwgY3JlYXRlIGEgbGludCBmYWlsdXJlLlxuICBpZiAodHMuaXNDbGFzc0VsZW1lbnQobm9kZSkgJiYgIWhhc092ZXJyaWRlTW9kaWZpZXIobm9kZSkgJiZcbiAgICAgIG1hdGNoZXNQYXJlbnRBYnN0cmFjdEVsZW1lbnQobm9kZSwgcHJvZ3JhbSkpIHtcbiAgICBjdHguYWRkRmFpbHVyZUF0Tm9kZShcbiAgICAgICAgbm9kZSwgRkFJTFVSRV9NRVNTQUdFLCBSZXBsYWNlbWVudC5hcHBlbmRUZXh0KG5vZGUuZ2V0U3RhcnQoKSwgYG92ZXJyaWRlIGApKTtcbiAgfVxuXG4gIHRzLmZvckVhY2hDaGlsZChub2RlLCBub2RlID0+IHZpc2l0Tm9kZShub2RlLCBjdHgsIHByb2dyYW0pKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBjbGFzcyBlbGVtZW50IG1hdGNoZXMgYSBwYXJlbnQgYWJzdHJhY3QgY2xhc3MgZWxlbWVudC4gaS5lLlxuICogd2hldGhlciB0aGUgc3BlY2lmaWVkIG1lbWJlciBcImltcGxlbWVudHNcIiBhbiBhYnN0cmFjdCBtZW1iZXIgZnJvbSBhIGJhc2UgY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNQYXJlbnRBYnN0cmFjdEVsZW1lbnQobm9kZTogdHMuQ2xhc3NFbGVtZW50LCBwcm9ncmFtOiB0cy5Qcm9ncmFtKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNvbnRhaW5pbmdDbGFzcyA9IG5vZGUucGFyZW50IGFzIHRzLkNsYXNzRGVjbGFyYXRpb247XG5cbiAgLy8gSWYgdGhlIHByb3BlcnR5IHdlIGNoZWNrIGRvZXMgbm90IGhhdmUgYSBwcm9wZXJ0eSBuYW1lLCB3ZSBjYW5ub3QgbG9vayBmb3Igc2ltaWxhcmx5LW5hbWVkXG4gIC8vIG1lbWJlcnMgaW4gcGFyZW50IGNsYXNzZXMgYW5kIHRoZXJlZm9yZSByZXR1cm4gZWFybHkuXG4gIGlmIChub2RlLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3BlcnR5TmFtZSA9IGdldFByb3BlcnR5TmFtZVRleHQobm9kZS5uYW1lKTtcbiAgY29uc3QgdHlwZUNoZWNrZXIgPSBwcm9ncmFtLmdldFR5cGVDaGVja2VyKCk7XG5cbiAgLy8gSWYgdGhlIHByb3BlcnR5IHdlIGNoZWNrIGRvZXMgbm90IGhhdmUgYSBzdGF0aWNhbGx5LWFuYWx5emFibGUgcHJvcGVydHkgbmFtZSxcbiAgLy8gd2UgY2Fubm90IGxvb2sgZm9yIHNpbWlsYXJseS1uYW1lZCBtZW1iZXJzIGluIHBhcmVudCBjbGFzc2VzIGFuZCByZXR1cm4gZWFybHkuXG4gIGlmIChwcm9wZXJ0eU5hbWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY2hlY2tDbGFzc0ZvckluaGVyaXRlZE1hdGNoaW5nQWJzdHJhY3RNZW1iZXIoY29udGFpbmluZ0NsYXNzLCB0eXBlQ2hlY2tlciwgcHJvcGVydHlOYW1lKTtcbn1cblxuLyoqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gY2xhc3MgaW5oZXJpdHMgYW4gYWJzdHJhY3QgbWVtYmVyIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLiAqL1xuZnVuY3Rpb24gY2hlY2tDbGFzc0ZvckluaGVyaXRlZE1hdGNoaW5nQWJzdHJhY3RNZW1iZXIoXG4gICAgY2xheno6IHRzLkNsYXNzRGVjbGFyYXRpb24sIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgc2VhcmNoTWVtYmVyTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGJhc2VDbGFzcyA9IGdldEJhc2VDbGFzcyhjbGF6eiwgdHlwZUNoZWNrZXIpO1xuXG4gIC8vIElmIHRoZSBjbGFzcyBpcyBub3QgYGFic3RyYWN0YCwgdGhlbiBhbGwgcGFyZW50IGFic3RyYWN0IG1ldGhvZHMgd291bGQgbmVlZCB0b1xuICAvLyBiZSBpbXBsZW1lbnRlZCwgYW5kIHRoZXJlIGlzIG5ldmVyIGFuIGFic3RyYWN0IG1lbWJlciB3aXRoaW4gdGhlIGNsYXNzLlxuICBpZiAoYmFzZUNsYXNzID09PSBudWxsIHx8ICFoYXNBYnN0cmFjdE1vZGlmaWVyKGJhc2VDbGFzcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBtYXRjaGluZ01lbWJlciA9IGJhc2VDbGFzcy5tZW1iZXJzLmZpbmQoXG4gICAgICBtID0+IG0ubmFtZSAhPT0gdW5kZWZpbmVkICYmIGdldFByb3BlcnR5TmFtZVRleHQobS5uYW1lKSA9PT0gc2VhcmNoTWVtYmVyTmFtZSk7XG5cbiAgaWYgKG1hdGNoaW5nTWVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzQWJzdHJhY3RNb2RpZmllcihtYXRjaGluZ01lbWJlcik7XG4gIH1cblxuICByZXR1cm4gY2hlY2tDbGFzc0ZvckluaGVyaXRlZE1hdGNoaW5nQWJzdHJhY3RNZW1iZXIoYmFzZUNsYXNzLCB0eXBlQ2hlY2tlciwgc2VhcmNoTWVtYmVyTmFtZSk7XG59XG5cbi8qKiBHZXRzIHRoZSBiYXNlIGNsYXNzIGZvciB0aGUgZ2l2ZW4gY2xhc3MgZGVjbGFyYXRpb24uICovXG5mdW5jdGlvbiBnZXRCYXNlQ2xhc3Mobm9kZTogdHMuQ2xhc3NEZWNsYXJhdGlvbiwgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyKTogdHMuQ2xhc3NEZWNsYXJhdGlvbnxcbiAgICBudWxsIHtcbiAgY29uc3QgYmFzZVR5cGVzID0gZ2V0RXh0ZW5kc0hlcml0YWdlRXhwcmVzc2lvbnMobm9kZSk7XG5cbiAgaWYgKGJhc2VUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0NsYXNzIHVuZXhwZWN0ZWRseSBleHRlbmRzIGZyb20gbXVsdGlwbGUgdHlwZXMuJyk7XG4gIH1cblxuICBjb25zdCBiYXNlQ2xhc3MgPSB0eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihiYXNlVHlwZXNbMF0pLmdldFN5bWJvbCgpO1xuICBjb25zdCBiYXNlQ2xhc3NEZWNsID0gYmFzZUNsYXNzPy52YWx1ZURlY2xhcmF0aW9uID8/IGJhc2VDbGFzcz8uZGVjbGFyYXRpb25zPy5bMF07XG5cbiAgaWYgKGJhc2VDbGFzc0RlY2wgIT09IHVuZGVmaW5lZCAmJiB0cy5pc0NsYXNzRGVjbGFyYXRpb24oYmFzZUNsYXNzRGVjbCkpIHtcbiAgICByZXR1cm4gYmFzZUNsYXNzRGVjbDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKiogR2V0cyB0aGUgYGV4dGVuZHNgIGJhc2UgdHlwZSBleHByZXNzaW9ucyBvZiB0aGUgc3BlY2lmaWVkIGNsYXNzLiAqL1xuZnVuY3Rpb24gZ2V0RXh0ZW5kc0hlcml0YWdlRXhwcmVzc2lvbnMoY2xhc3NEZWNsOiB0cy5DbGFzc0RlY2xhcmF0aW9uKTpcbiAgICB0cy5FeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNbXSB7XG4gIGlmIChjbGFzc0RlY2wuaGVyaXRhZ2VDbGF1c2VzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgcmVzdWx0OiB0cy5FeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXVzZSBvZiBjbGFzc0RlY2wuaGVyaXRhZ2VDbGF1c2VzKSB7XG4gICAgaWYgKGNsYXVzZS50b2tlbiA9PT0gdHMuU3ludGF4S2luZC5FeHRlbmRzS2V5d29yZCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uY2xhdXNlLnR5cGVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEdldHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIG5vZGUgaGFzIHRoZSBgYWJzdHJhY3RgIG1vZGlmaWVyIGFwcGxpZWQuICovXG5mdW5jdGlvbiBoYXNBYnN0cmFjdE1vZGlmaWVyKG5vZGU6IHRzLk5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhbm9kZS5tb2RpZmllcnM/LnNvbWUocyA9PiBzLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQWJzdHJhY3RLZXl3b3JkKTtcbn1cblxuLyoqIEdldHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIG5vZGUgaGFzIHRoZSBgb3ZlcnJpZGVgIG1vZGlmaWVyIGFwcGxpZWQuICovXG5mdW5jdGlvbiBoYXNPdmVycmlkZU1vZGlmaWVyKG5vZGU6IHRzLk5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhbm9kZS5tb2RpZmllcnM/LnNvbWUocyA9PiBzLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuT3ZlcnJpZGVLZXl3b3JkKTtcbn1cblxuLyoqIEdldHMgdGhlIHByb3BlcnR5IG5hbWUgdGV4dCBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUuICovXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eU5hbWVUZXh0KG5hbWU6IHRzLlByb3BlcnR5TmFtZSk6IHN0cmluZ3xudWxsIHtcbiAgaWYgKHRzLmlzQ29tcHV0ZWRQcm9wZXJ0eU5hbWUobmFtZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbmFtZS50ZXh0O1xufVxuIl19