"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCommitsForRevisionRange = exports.getCommitsForRangeWithDeduping = void 0;
const parse_1 = require("../../../commit-message/parse");
const unique_commit_id_1 = require("./unique-commit-id");
/**
 * Gets all commits the head branch contains, but the base branch does not include.
 * This follows the same semantics as Git's double-dot revision range.
 *
 * i.e. `<baseRef>..<headRef>` revision range as per Git.
 * https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection.
 *
 * Branches in the Angular organization are diverging quickly due to multiple factors
 * concerning the versioning and merging. i.e. Commits are cherry-picked into branches,
 * resulting in different SHAs for each branch. Additionally, branches diverge quickly
 * because changes can be made only for specific branches (e.g. a master-only change).
 *
 * In order to allow for comparisons that follow similar semantics as Git's double-dot
 * revision range syntax, the logic re-implementing the semantics need to account for
 * the mentioned semi-diverged branches. We achieve this by excluding commits in the
 * head branch which have a similarly-named commit in the base branch. We cannot rely on
 * SHAs for determining common commits between the two branches (as explained above).
 *
 * More details can be found in the `get-commits-in-range.png` file which illustrates a
 * scenario where commits from the patch branch need to be excluded from the main branch.
 */
function getCommitsForRangeWithDeduping(client, baseRef, headRef) {
    const commits = [];
    const commitsForHead = fetchCommitsForRevisionRange(client, `${baseRef}..${headRef}`);
    const commitsForBase = fetchCommitsForRevisionRange(client, `${headRef}..${baseRef}`);
    // Map that keeps track of commits within the base branch. Commits are
    // stored with an unique id based on the commit message. If a similarly-named
    // commit appears multiple times, the value number will reflect that.
    const knownCommitsOnlyInBase = new Map();
    for (const commit of commitsForBase) {
        const id = (0, unique_commit_id_1.computeUniqueIdFromCommitMessage)(commit);
        const numSimilarCommits = knownCommitsOnlyInBase.get(id) ?? 0;
        knownCommitsOnlyInBase.set(id, numSimilarCommits + 1);
    }
    for (const commit of commitsForHead) {
        const id = (0, unique_commit_id_1.computeUniqueIdFromCommitMessage)(commit);
        const numSimilarCommits = knownCommitsOnlyInBase.get(id) ?? 0;
        // If there is a similar commit in the base branch, the current commit in the head branch
        // needs to be skipped. We keep track of the number of similar commits so that we do not
        // accidentally "dedupe" a commit. e.g. consider a case where commit `X` lands in the
        // patch branch and next branch. Then a similar similarly named commits lands only in the
        // next branch. We would not want to omit that one as it is not part of the patch branch.
        if (numSimilarCommits > 0) {
            knownCommitsOnlyInBase.set(id, numSimilarCommits - 1);
            continue;
        }
        commits.push(commit);
    }
    return commits;
}
exports.getCommitsForRangeWithDeduping = getCommitsForRangeWithDeduping;
/** Fetches commits for the given revision range using `git log`. */
function fetchCommitsForRevisionRange(client, revisionRange) {
    const splitDelimiter = '-------------ɵɵ------------';
    const output = client.run([
        'log',
        `--format=${parse_1.gitLogFormatForParsing}${splitDelimiter}`,
        revisionRange,
    ]);
    return output.stdout
        .split(splitDelimiter)
        .filter((entry) => !!entry.trim())
        .map((entry) => (0, parse_1.parseCommitFromGitLog)(Buffer.from(entry, 'utf-8')));
}
exports.fetchCommitsForRevisionRange = fetchCommitsForRevisionRange;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LWNvbW1pdHMtaW4tcmFuZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9uZy1kZXYvcmVsZWFzZS9ub3Rlcy9jb21taXRzL2dldC1jb21taXRzLWluLXJhbmdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7OztBQUdILHlEQUl1QztBQUN2Qyx5REFBb0U7QUFFcEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JHO0FBQ0gsU0FBZ0IsOEJBQThCLENBQzVDLE1BQWlCLEVBQ2pCLE9BQWUsRUFDZixPQUFlO0lBRWYsTUFBTSxPQUFPLEdBQXVCLEVBQUUsQ0FBQztJQUN2QyxNQUFNLGNBQWMsR0FBRyw0QkFBNEIsQ0FBQyxNQUFNLEVBQUUsR0FBRyxPQUFPLEtBQUssT0FBTyxFQUFFLENBQUMsQ0FBQztJQUN0RixNQUFNLGNBQWMsR0FBRyw0QkFBNEIsQ0FBQyxNQUFNLEVBQUUsR0FBRyxPQUFPLEtBQUssT0FBTyxFQUFFLENBQUMsQ0FBQztJQUV0RixzRUFBc0U7SUFDdEUsNkVBQTZFO0lBQzdFLHFFQUFxRTtJQUNyRSxNQUFNLHNCQUFzQixHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO0lBRXpELEtBQUssTUFBTSxNQUFNLElBQUksY0FBYyxFQUFFO1FBQ25DLE1BQU0sRUFBRSxHQUFHLElBQUEsbURBQWdDLEVBQUMsTUFBTSxDQUFDLENBQUM7UUFDcEQsTUFBTSxpQkFBaUIsR0FBRyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlELHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLENBQUM7S0FDdkQ7SUFFRCxLQUFLLE1BQU0sTUFBTSxJQUFJLGNBQWMsRUFBRTtRQUNuQyxNQUFNLEVBQUUsR0FBRyxJQUFBLG1EQUFnQyxFQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3BELE1BQU0saUJBQWlCLEdBQUcsc0JBQXNCLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUU5RCx5RkFBeUY7UUFDekYsd0ZBQXdGO1FBQ3hGLHFGQUFxRjtRQUNyRix5RkFBeUY7UUFDekYseUZBQXlGO1FBQ3pGLElBQUksaUJBQWlCLEdBQUcsQ0FBQyxFQUFFO1lBQ3pCLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDdEQsU0FBUztTQUNWO1FBRUQsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUN0QjtJQUVELE9BQU8sT0FBTyxDQUFDO0FBQ2pCLENBQUM7QUF0Q0Qsd0VBc0NDO0FBRUQsb0VBQW9FO0FBQ3BFLFNBQWdCLDRCQUE0QixDQUMxQyxNQUFpQixFQUNqQixhQUFxQjtJQUVyQixNQUFNLGNBQWMsR0FBRyw2QkFBNkIsQ0FBQztJQUNyRCxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDO1FBQ3hCLEtBQUs7UUFDTCxZQUFZLDhCQUFzQixHQUFHLGNBQWMsRUFBRTtRQUNyRCxhQUFhO0tBQ2QsQ0FBQyxDQUFDO0lBRUgsT0FBTyxNQUFNLENBQUMsTUFBTTtTQUNqQixLQUFLLENBQUMsY0FBYyxDQUFDO1NBQ3JCLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUNqQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUEsNkJBQXFCLEVBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hFLENBQUM7QUFmRCxvRUFlQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0dpdENsaWVudH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZ2l0L2dpdC1jbGllbnQnO1xuaW1wb3J0IHtcbiAgQ29tbWl0RnJvbUdpdExvZyxcbiAgZ2l0TG9nRm9ybWF0Rm9yUGFyc2luZyxcbiAgcGFyc2VDb21taXRGcm9tR2l0TG9nLFxufSBmcm9tICcuLi8uLi8uLi9jb21taXQtbWVzc2FnZS9wYXJzZSc7XG5pbXBvcnQge2NvbXB1dGVVbmlxdWVJZEZyb21Db21taXRNZXNzYWdlfSBmcm9tICcuL3VuaXF1ZS1jb21taXQtaWQnO1xuXG4vKipcbiAqIEdldHMgYWxsIGNvbW1pdHMgdGhlIGhlYWQgYnJhbmNoIGNvbnRhaW5zLCBidXQgdGhlIGJhc2UgYnJhbmNoIGRvZXMgbm90IGluY2x1ZGUuXG4gKiBUaGlzIGZvbGxvd3MgdGhlIHNhbWUgc2VtYW50aWNzIGFzIEdpdCdzIGRvdWJsZS1kb3QgcmV2aXNpb24gcmFuZ2UuXG4gKlxuICogaS5lLiBgPGJhc2VSZWY+Li48aGVhZFJlZj5gIHJldmlzaW9uIHJhbmdlIGFzIHBlciBHaXQuXG4gKiBodHRwczovL2dpdC1zY20uY29tL2Jvb2svZW4vdjIvR2l0LVRvb2xzLVJldmlzaW9uLVNlbGVjdGlvbi5cbiAqXG4gKiBCcmFuY2hlcyBpbiB0aGUgQW5ndWxhciBvcmdhbml6YXRpb24gYXJlIGRpdmVyZ2luZyBxdWlja2x5IGR1ZSB0byBtdWx0aXBsZSBmYWN0b3JzXG4gKiBjb25jZXJuaW5nIHRoZSB2ZXJzaW9uaW5nIGFuZCBtZXJnaW5nLiBpLmUuIENvbW1pdHMgYXJlIGNoZXJyeS1waWNrZWQgaW50byBicmFuY2hlcyxcbiAqIHJlc3VsdGluZyBpbiBkaWZmZXJlbnQgU0hBcyBmb3IgZWFjaCBicmFuY2guIEFkZGl0aW9uYWxseSwgYnJhbmNoZXMgZGl2ZXJnZSBxdWlja2x5XG4gKiBiZWNhdXNlIGNoYW5nZXMgY2FuIGJlIG1hZGUgb25seSBmb3Igc3BlY2lmaWMgYnJhbmNoZXMgKGUuZy4gYSBtYXN0ZXItb25seSBjaGFuZ2UpLlxuICpcbiAqIEluIG9yZGVyIHRvIGFsbG93IGZvciBjb21wYXJpc29ucyB0aGF0IGZvbGxvdyBzaW1pbGFyIHNlbWFudGljcyBhcyBHaXQncyBkb3VibGUtZG90XG4gKiByZXZpc2lvbiByYW5nZSBzeW50YXgsIHRoZSBsb2dpYyByZS1pbXBsZW1lbnRpbmcgdGhlIHNlbWFudGljcyBuZWVkIHRvIGFjY291bnQgZm9yXG4gKiB0aGUgbWVudGlvbmVkIHNlbWktZGl2ZXJnZWQgYnJhbmNoZXMuIFdlIGFjaGlldmUgdGhpcyBieSBleGNsdWRpbmcgY29tbWl0cyBpbiB0aGVcbiAqIGhlYWQgYnJhbmNoIHdoaWNoIGhhdmUgYSBzaW1pbGFybHktbmFtZWQgY29tbWl0IGluIHRoZSBiYXNlIGJyYW5jaC4gV2UgY2Fubm90IHJlbHkgb25cbiAqIFNIQXMgZm9yIGRldGVybWluaW5nIGNvbW1vbiBjb21taXRzIGJldHdlZW4gdGhlIHR3byBicmFuY2hlcyAoYXMgZXhwbGFpbmVkIGFib3ZlKS5cbiAqXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGluIHRoZSBgZ2V0LWNvbW1pdHMtaW4tcmFuZ2UucG5nYCBmaWxlIHdoaWNoIGlsbHVzdHJhdGVzIGFcbiAqIHNjZW5hcmlvIHdoZXJlIGNvbW1pdHMgZnJvbSB0aGUgcGF0Y2ggYnJhbmNoIG5lZWQgdG8gYmUgZXhjbHVkZWQgZnJvbSB0aGUgbWFpbiBicmFuY2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21taXRzRm9yUmFuZ2VXaXRoRGVkdXBpbmcoXG4gIGNsaWVudDogR2l0Q2xpZW50LFxuICBiYXNlUmVmOiBzdHJpbmcsXG4gIGhlYWRSZWY6IHN0cmluZyxcbik6IENvbW1pdEZyb21HaXRMb2dbXSB7XG4gIGNvbnN0IGNvbW1pdHM6IENvbW1pdEZyb21HaXRMb2dbXSA9IFtdO1xuICBjb25zdCBjb21taXRzRm9ySGVhZCA9IGZldGNoQ29tbWl0c0ZvclJldmlzaW9uUmFuZ2UoY2xpZW50LCBgJHtiYXNlUmVmfS4uJHtoZWFkUmVmfWApO1xuICBjb25zdCBjb21taXRzRm9yQmFzZSA9IGZldGNoQ29tbWl0c0ZvclJldmlzaW9uUmFuZ2UoY2xpZW50LCBgJHtoZWFkUmVmfS4uJHtiYXNlUmVmfWApO1xuXG4gIC8vIE1hcCB0aGF0IGtlZXBzIHRyYWNrIG9mIGNvbW1pdHMgd2l0aGluIHRoZSBiYXNlIGJyYW5jaC4gQ29tbWl0cyBhcmVcbiAgLy8gc3RvcmVkIHdpdGggYW4gdW5pcXVlIGlkIGJhc2VkIG9uIHRoZSBjb21taXQgbWVzc2FnZS4gSWYgYSBzaW1pbGFybHktbmFtZWRcbiAgLy8gY29tbWl0IGFwcGVhcnMgbXVsdGlwbGUgdGltZXMsIHRoZSB2YWx1ZSBudW1iZXIgd2lsbCByZWZsZWN0IHRoYXQuXG4gIGNvbnN0IGtub3duQ29tbWl0c09ubHlJbkJhc2UgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gIGZvciAoY29uc3QgY29tbWl0IG9mIGNvbW1pdHNGb3JCYXNlKSB7XG4gICAgY29uc3QgaWQgPSBjb21wdXRlVW5pcXVlSWRGcm9tQ29tbWl0TWVzc2FnZShjb21taXQpO1xuICAgIGNvbnN0IG51bVNpbWlsYXJDb21taXRzID0ga25vd25Db21taXRzT25seUluQmFzZS5nZXQoaWQpID8/IDA7XG4gICAga25vd25Db21taXRzT25seUluQmFzZS5zZXQoaWQsIG51bVNpbWlsYXJDb21taXRzICsgMSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGNvbW1pdCBvZiBjb21taXRzRm9ySGVhZCkge1xuICAgIGNvbnN0IGlkID0gY29tcHV0ZVVuaXF1ZUlkRnJvbUNvbW1pdE1lc3NhZ2UoY29tbWl0KTtcbiAgICBjb25zdCBudW1TaW1pbGFyQ29tbWl0cyA9IGtub3duQ29tbWl0c09ubHlJbkJhc2UuZ2V0KGlkKSA/PyAwO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBzaW1pbGFyIGNvbW1pdCBpbiB0aGUgYmFzZSBicmFuY2gsIHRoZSBjdXJyZW50IGNvbW1pdCBpbiB0aGUgaGVhZCBicmFuY2hcbiAgICAvLyBuZWVkcyB0byBiZSBza2lwcGVkLiBXZSBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2Ygc2ltaWxhciBjb21taXRzIHNvIHRoYXQgd2UgZG8gbm90XG4gICAgLy8gYWNjaWRlbnRhbGx5IFwiZGVkdXBlXCIgYSBjb21taXQuIGUuZy4gY29uc2lkZXIgYSBjYXNlIHdoZXJlIGNvbW1pdCBgWGAgbGFuZHMgaW4gdGhlXG4gICAgLy8gcGF0Y2ggYnJhbmNoIGFuZCBuZXh0IGJyYW5jaC4gVGhlbiBhIHNpbWlsYXIgc2ltaWxhcmx5IG5hbWVkIGNvbW1pdHMgbGFuZHMgb25seSBpbiB0aGVcbiAgICAvLyBuZXh0IGJyYW5jaC4gV2Ugd291bGQgbm90IHdhbnQgdG8gb21pdCB0aGF0IG9uZSBhcyBpdCBpcyBub3QgcGFydCBvZiB0aGUgcGF0Y2ggYnJhbmNoLlxuICAgIGlmIChudW1TaW1pbGFyQ29tbWl0cyA+IDApIHtcbiAgICAgIGtub3duQ29tbWl0c09ubHlJbkJhc2Uuc2V0KGlkLCBudW1TaW1pbGFyQ29tbWl0cyAtIDEpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29tbWl0cy5wdXNoKGNvbW1pdCk7XG4gIH1cblxuICByZXR1cm4gY29tbWl0cztcbn1cblxuLyoqIEZldGNoZXMgY29tbWl0cyBmb3IgdGhlIGdpdmVuIHJldmlzaW9uIHJhbmdlIHVzaW5nIGBnaXQgbG9nYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaENvbW1pdHNGb3JSZXZpc2lvblJhbmdlKFxuICBjbGllbnQ6IEdpdENsaWVudCxcbiAgcmV2aXNpb25SYW5nZTogc3RyaW5nLFxuKTogQ29tbWl0RnJvbUdpdExvZ1tdIHtcbiAgY29uc3Qgc3BsaXREZWxpbWl0ZXIgPSAnLS0tLS0tLS0tLS0tLcm1ybUtLS0tLS0tLS0tLS0nO1xuICBjb25zdCBvdXRwdXQgPSBjbGllbnQucnVuKFtcbiAgICAnbG9nJyxcbiAgICBgLS1mb3JtYXQ9JHtnaXRMb2dGb3JtYXRGb3JQYXJzaW5nfSR7c3BsaXREZWxpbWl0ZXJ9YCxcbiAgICByZXZpc2lvblJhbmdlLFxuICBdKTtcblxuICByZXR1cm4gb3V0cHV0LnN0ZG91dFxuICAgIC5zcGxpdChzcGxpdERlbGltaXRlcilcbiAgICAuZmlsdGVyKChlbnRyeSkgPT4gISFlbnRyeS50cmltKCkpXG4gICAgLm1hcCgoZW50cnkpID0+IHBhcnNlQ29tbWl0RnJvbUdpdExvZyhCdWZmZXIuZnJvbShlbnRyeSwgJ3V0Zi04JykpKTtcbn1cbiJdfQ==