"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBranchesForMajorVersions = exports.getVersionForVersionBranch = exports.isVersionBranch = exports.getVersionOfBranch = exports.getNextBranchName = void 0;
const semver = require("semver");
/** Regular expression that matches version-branches. */
const versionBranchNameRegex = /^(\d+)\.(\d+)\.x$/;
/**
 * Gets the name of the next branch from the Github configuration.
 *
 * Note that there is a clear separation between the main branch of the
 * upstream remote repository and the `next` release-train branch.
 */
function getNextBranchName(github) {
    return github.mainBranchName;
}
exports.getNextBranchName = getNextBranchName;
/** Gets the version of a given branch by reading the `package.json` upstream. */
async function getVersionOfBranch(repo, branchName) {
    const { data } = await repo.api.repos.getContent({
        owner: repo.owner,
        repo: repo.name,
        path: '/package.json',
        ref: branchName,
    });
    // Workaround for: https://github.com/octokit/rest.js/issues/32.
    // TODO: Remove cast once types of Octokit `getContent` are fixed.
    const content = data.content;
    if (!content) {
        throw Error(`Unable to read "package.json" file from repository.`);
    }
    const { version } = JSON.parse(Buffer.from(content, 'base64').toString());
    const parsedVersion = semver.parse(version);
    if (parsedVersion === null) {
        throw Error(`Invalid version detected in following branch: ${branchName}.`);
    }
    return parsedVersion;
}
exports.getVersionOfBranch = getVersionOfBranch;
/** Whether the given branch corresponds to a version branch. */
function isVersionBranch(branchName) {
    return versionBranchNameRegex.test(branchName);
}
exports.isVersionBranch = isVersionBranch;
/**
 * Converts a given version-branch into a SemVer version that can be used with SemVer
 * utilities. e.g. to determine semantic order, extract major digit, compare.
 *
 * For example `10.0.x` will become `10.0.0` in SemVer. The patch digit is not
 * relevant but needed for parsing. SemVer does not allow `x` as patch digit.
 */
function getVersionForVersionBranch(branchName) {
    return semver.parse(branchName.replace(versionBranchNameRegex, '$1.$2.0'));
}
exports.getVersionForVersionBranch = getVersionForVersionBranch;
/**
 * Gets the version branches for the specified major versions in descending
 * order. i.e. latest version branches first.
 */
async function getBranchesForMajorVersions(repo, majorVersions) {
    const branchData = await repo.api.paginate(repo.api.repos.listBranches, {
        owner: repo.owner,
        repo: repo.name,
        protected: true,
    });
    const branches = [];
    for (const { name } of branchData) {
        if (!isVersionBranch(name)) {
            continue;
        }
        // Convert the version-branch into a SemVer version that can be used with the
        // SemVer utilities. e.g. to determine semantic order, compare versions.
        const parsed = getVersionForVersionBranch(name);
        // Collect all version-branches that match the specified major versions.
        if (parsed !== null && majorVersions.includes(parsed.major)) {
            branches.push({ name, parsed });
        }
    }
    // Sort captured version-branches in descending order.
    return branches.sort((a, b) => semver.rcompare(a.parsed, b.parsed));
}
exports.getBranchesForMajorVersions = getBranchesForMajorVersions;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi1icmFuY2hlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL25nLWRldi9yZWxlYXNlL3ZlcnNpb25pbmcvdmVyc2lvbi1icmFuY2hlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HOzs7QUFFSCxpQ0FBaUM7QUF3QmpDLHdEQUF3RDtBQUN4RCxNQUFNLHNCQUFzQixHQUFHLG1CQUFtQixDQUFDO0FBRW5EOzs7OztHQUtHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQUMsTUFBdUI7SUFDdkQsT0FBTyxNQUFNLENBQUMsY0FBYyxDQUFDO0FBQy9CLENBQUM7QUFGRCw4Q0FFQztBQUVELGlGQUFpRjtBQUMxRSxLQUFLLFVBQVUsa0JBQWtCLENBQ3RDLElBQXdCLEVBQ3hCLFVBQWtCO0lBRWxCLE1BQU0sRUFBQyxJQUFJLEVBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQztRQUM3QyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7UUFDakIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1FBQ2YsSUFBSSxFQUFFLGVBQWU7UUFDckIsR0FBRyxFQUFFLFVBQVU7S0FDaEIsQ0FBQyxDQUFDO0lBQ0gsZ0VBQWdFO0lBQ2hFLGtFQUFrRTtJQUNsRSxNQUFNLE9BQU8sR0FBSSxJQUEyQixDQUFDLE9BQU8sQ0FBQztJQUNyRCxJQUFJLENBQUMsT0FBTyxFQUFFO1FBQ1osTUFBTSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztLQUNwRTtJQUNELE1BQU0sRUFBQyxPQUFPLEVBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUdyRSxDQUFDO0lBQ0YsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM1QyxJQUFJLGFBQWEsS0FBSyxJQUFJLEVBQUU7UUFDMUIsTUFBTSxLQUFLLENBQUMsaURBQWlELFVBQVUsR0FBRyxDQUFDLENBQUM7S0FDN0U7SUFDRCxPQUFPLGFBQWEsQ0FBQztBQUN2QixDQUFDO0FBekJELGdEQXlCQztBQUVELGdFQUFnRTtBQUNoRSxTQUFnQixlQUFlLENBQUMsVUFBa0I7SUFDaEQsT0FBTyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUZELDBDQUVDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsMEJBQTBCLENBQUMsVUFBa0I7SUFDM0QsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsc0JBQXNCLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUM3RSxDQUFDO0FBRkQsZ0VBRUM7QUFFRDs7O0dBR0c7QUFDSSxLQUFLLFVBQVUsMkJBQTJCLENBQy9DLElBQXdCLEVBQ3hCLGFBQXVCO0lBRXZCLE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFO1FBQ3RFLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztRQUNqQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7UUFDZixTQUFTLEVBQUUsSUFBSTtLQUNoQixDQUFDLENBQUM7SUFDSCxNQUFNLFFBQVEsR0FBb0IsRUFBRSxDQUFDO0lBRXJDLEtBQUssTUFBTSxFQUFDLElBQUksRUFBQyxJQUFJLFVBQVUsRUFBRTtRQUMvQixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzFCLFNBQVM7U0FDVjtRQUNELDZFQUE2RTtRQUM3RSx3RUFBd0U7UUFDeEUsTUFBTSxNQUFNLEdBQUcsMEJBQTBCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEQsd0VBQXdFO1FBQ3hFLElBQUksTUFBTSxLQUFLLElBQUksSUFBSSxhQUFhLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUMzRCxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBQyxDQUFDLENBQUM7U0FDL0I7S0FDRjtJQUVELHNEQUFzRDtJQUN0RCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDdEUsQ0FBQztBQTFCRCxrRUEwQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQge0dpdGh1YkNsaWVudCwgR2l0aHViUmVwb30gZnJvbSAnLi4vLi4vdXRpbHMvZ2l0L2dpdGh1Yic7XG5pbXBvcnQge0dpdENsaWVudENvbmZpZ30gZnJvbSAnLi4vLi4vdXRpbHMvY29uZmlnJztcblxuLyoqIE9iamVjdCBkZXNjcmliaW5nIGEgcmVwb3NpdG9yeSB0aGF0IGNhbiBiZSByZWxlYXNlZCwgdG9nZXRoZXIgd2l0aCBhbiBBUEkgY2xpZW50LiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZWxlYXNlUmVwb1dpdGhBcGkgZXh0ZW5kcyBHaXRodWJSZXBvIHtcbiAgLyoqIEFQSSBjbGllbnQgdGhhdCBjYW4gYWNjZXNzIHRoZSByZXBvc2l0b3J5LiAqL1xuICBhcGk6IEdpdGh1YkNsaWVudDtcbiAgLyoqIE5hbWUgb2YgdGhlIG5leHQgYnJhbmNoLiAqL1xuICBuZXh0QnJhbmNoTmFtZTogc3RyaW5nO1xufVxuXG4vKiogVHlwZSBkZXNjcmliaW5nIGEgdmVyc2lvbi1icmFuY2guICovXG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb25CcmFuY2gge1xuICAvKiogTmFtZSBvZiB0aGUgYnJhbmNoIGluIEdpdC4gZS5nLiBgMTAuMC54YC4gKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogUGFyc2VkIFNlbVZlciB2ZXJzaW9uIGZvciB0aGUgdmVyc2lvbi1icmFuY2guIFZlcnNpb24gYnJhbmNoZXMgdGVjaG5pY2FsbHkgZG9cbiAgICogbm90IGZvbGxvdyB0aGUgU2VtVmVyIGZvcm1hdCwgYnV0IHdlIGNhbiBoYXZlIHJlcHJlc2VudGF0aXZlIFNlbVZlciB2ZXJzaW9uc1xuICAgKiB0aGF0IGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29ucywgc29ydGluZyBhbmQgb3RoZXIgY2hlY2tzLlxuICAgKi9cbiAgcGFyc2VkOiBzZW12ZXIuU2VtVmVyO1xufVxuXG4vKiogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyB2ZXJzaW9uLWJyYW5jaGVzLiAqL1xuY29uc3QgdmVyc2lvbkJyYW5jaE5hbWVSZWdleCA9IC9eKFxcZCspXFwuKFxcZCspXFwueCQvO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIG5leHQgYnJhbmNoIGZyb20gdGhlIEdpdGh1YiBjb25maWd1cmF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCB0aGVyZSBpcyBhIGNsZWFyIHNlcGFyYXRpb24gYmV0d2VlbiB0aGUgbWFpbiBicmFuY2ggb2YgdGhlXG4gKiB1cHN0cmVhbSByZW1vdGUgcmVwb3NpdG9yeSBhbmQgdGhlIGBuZXh0YCByZWxlYXNlLXRyYWluIGJyYW5jaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRCcmFuY2hOYW1lKGdpdGh1YjogR2l0Q2xpZW50Q29uZmlnKTogc3RyaW5nIHtcbiAgcmV0dXJuIGdpdGh1Yi5tYWluQnJhbmNoTmFtZTtcbn1cblxuLyoqIEdldHMgdGhlIHZlcnNpb24gb2YgYSBnaXZlbiBicmFuY2ggYnkgcmVhZGluZyB0aGUgYHBhY2thZ2UuanNvbmAgdXBzdHJlYW0uICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VmVyc2lvbk9mQnJhbmNoKFxuICByZXBvOiBSZWxlYXNlUmVwb1dpdGhBcGksXG4gIGJyYW5jaE5hbWU6IHN0cmluZyxcbik6IFByb21pc2U8c2VtdmVyLlNlbVZlcj4ge1xuICBjb25zdCB7ZGF0YX0gPSBhd2FpdCByZXBvLmFwaS5yZXBvcy5nZXRDb250ZW50KHtcbiAgICBvd25lcjogcmVwby5vd25lcixcbiAgICByZXBvOiByZXBvLm5hbWUsXG4gICAgcGF0aDogJy9wYWNrYWdlLmpzb24nLFxuICAgIHJlZjogYnJhbmNoTmFtZSxcbiAgfSk7XG4gIC8vIFdvcmthcm91bmQgZm9yOiBodHRwczovL2dpdGh1Yi5jb20vb2N0b2tpdC9yZXN0LmpzL2lzc3Vlcy8zMi5cbiAgLy8gVE9ETzogUmVtb3ZlIGNhc3Qgb25jZSB0eXBlcyBvZiBPY3Rva2l0IGBnZXRDb250ZW50YCBhcmUgZml4ZWQuXG4gIGNvbnN0IGNvbnRlbnQgPSAoZGF0YSBhcyB7Y29udGVudD86IHN0cmluZ30pLmNvbnRlbnQ7XG4gIGlmICghY29udGVudCkge1xuICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gcmVhZCBcInBhY2thZ2UuanNvblwiIGZpbGUgZnJvbSByZXBvc2l0b3J5LmApO1xuICB9XG4gIGNvbnN0IHt2ZXJzaW9ufSA9IEpTT04ucGFyc2UoQnVmZmVyLmZyb20oY29udGVudCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCkpIGFzIHtcbiAgICB2ZXJzaW9uOiBzdHJpbmc7XG4gICAgW2tleTogc3RyaW5nXTogYW55O1xuICB9O1xuICBjb25zdCBwYXJzZWRWZXJzaW9uID0gc2VtdmVyLnBhcnNlKHZlcnNpb24pO1xuICBpZiAocGFyc2VkVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgIHRocm93IEVycm9yKGBJbnZhbGlkIHZlcnNpb24gZGV0ZWN0ZWQgaW4gZm9sbG93aW5nIGJyYW5jaDogJHticmFuY2hOYW1lfS5gKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkVmVyc2lvbjtcbn1cblxuLyoqIFdoZXRoZXIgdGhlIGdpdmVuIGJyYW5jaCBjb3JyZXNwb25kcyB0byBhIHZlcnNpb24gYnJhbmNoLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2lvbkJyYW5jaChicmFuY2hOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHZlcnNpb25CcmFuY2hOYW1lUmVnZXgudGVzdChicmFuY2hOYW1lKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGdpdmVuIHZlcnNpb24tYnJhbmNoIGludG8gYSBTZW1WZXIgdmVyc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHdpdGggU2VtVmVyXG4gKiB1dGlsaXRpZXMuIGUuZy4gdG8gZGV0ZXJtaW5lIHNlbWFudGljIG9yZGVyLCBleHRyYWN0IG1ham9yIGRpZ2l0LCBjb21wYXJlLlxuICpcbiAqIEZvciBleGFtcGxlIGAxMC4wLnhgIHdpbGwgYmVjb21lIGAxMC4wLjBgIGluIFNlbVZlci4gVGhlIHBhdGNoIGRpZ2l0IGlzIG5vdFxuICogcmVsZXZhbnQgYnV0IG5lZWRlZCBmb3IgcGFyc2luZy4gU2VtVmVyIGRvZXMgbm90IGFsbG93IGB4YCBhcyBwYXRjaCBkaWdpdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZlcnNpb25Gb3JWZXJzaW9uQnJhbmNoKGJyYW5jaE5hbWU6IHN0cmluZyk6IHNlbXZlci5TZW1WZXIgfCBudWxsIHtcbiAgcmV0dXJuIHNlbXZlci5wYXJzZShicmFuY2hOYW1lLnJlcGxhY2UodmVyc2lvbkJyYW5jaE5hbWVSZWdleCwgJyQxLiQyLjAnKSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmVyc2lvbiBicmFuY2hlcyBmb3IgdGhlIHNwZWNpZmllZCBtYWpvciB2ZXJzaW9ucyBpbiBkZXNjZW5kaW5nXG4gKiBvcmRlci4gaS5lLiBsYXRlc3QgdmVyc2lvbiBicmFuY2hlcyBmaXJzdC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyYW5jaGVzRm9yTWFqb3JWZXJzaW9ucyhcbiAgcmVwbzogUmVsZWFzZVJlcG9XaXRoQXBpLFxuICBtYWpvclZlcnNpb25zOiBudW1iZXJbXSxcbik6IFByb21pc2U8VmVyc2lvbkJyYW5jaFtdPiB7XG4gIGNvbnN0IGJyYW5jaERhdGEgPSBhd2FpdCByZXBvLmFwaS5wYWdpbmF0ZShyZXBvLmFwaS5yZXBvcy5saXN0QnJhbmNoZXMsIHtcbiAgICBvd25lcjogcmVwby5vd25lcixcbiAgICByZXBvOiByZXBvLm5hbWUsXG4gICAgcHJvdGVjdGVkOiB0cnVlLFxuICB9KTtcbiAgY29uc3QgYnJhbmNoZXM6IFZlcnNpb25CcmFuY2hbXSA9IFtdO1xuXG4gIGZvciAoY29uc3Qge25hbWV9IG9mIGJyYW5jaERhdGEpIHtcbiAgICBpZiAoIWlzVmVyc2lvbkJyYW5jaChuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIHZlcnNpb24tYnJhbmNoIGludG8gYSBTZW1WZXIgdmVyc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHdpdGggdGhlXG4gICAgLy8gU2VtVmVyIHV0aWxpdGllcy4gZS5nLiB0byBkZXRlcm1pbmUgc2VtYW50aWMgb3JkZXIsIGNvbXBhcmUgdmVyc2lvbnMuXG4gICAgY29uc3QgcGFyc2VkID0gZ2V0VmVyc2lvbkZvclZlcnNpb25CcmFuY2gobmFtZSk7XG4gICAgLy8gQ29sbGVjdCBhbGwgdmVyc2lvbi1icmFuY2hlcyB0aGF0IG1hdGNoIHRoZSBzcGVjaWZpZWQgbWFqb3IgdmVyc2lvbnMuXG4gICAgaWYgKHBhcnNlZCAhPT0gbnVsbCAmJiBtYWpvclZlcnNpb25zLmluY2x1ZGVzKHBhcnNlZC5tYWpvcikpIHtcbiAgICAgIGJyYW5jaGVzLnB1c2goe25hbWUsIHBhcnNlZH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNvcnQgY2FwdHVyZWQgdmVyc2lvbi1icmFuY2hlcyBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICByZXR1cm4gYnJhbmNoZXMuc29ydCgoYSwgYikgPT4gc2VtdmVyLnJjb21wYXJlKGEucGFyc2VkLCBiLnBhcnNlZCkpO1xufVxuIl19