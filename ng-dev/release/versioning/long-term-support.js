"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLtsNpmDistTagOfMajor = exports.computeLtsEndDateOfMajor = exports.isLtsDistTag = exports.fetchLongTermSupportBranchesFromNpm = void 0;
const semver = require("semver");
const npm_registry_1 = require("./npm-registry");
/**
 * Number of months a major version in Angular is actively supported. See:
 * https://angular.io/guide/releases#support-policy-and-schedule.
 */
const majorActiveSupportDuration = 6;
/**
 * Number of months a major version has active long-term support. See:
 * https://angular.io/guide/releases#support-policy-and-schedule.
 */
const majorLongTermSupportDuration = 12;
/** Regular expression that matches LTS NPM dist tags. */
const ltsNpmDistTagRegex = /^v(\d+)-lts$/;
/** Finds all long-term support release trains from the specified NPM package. */
async function fetchLongTermSupportBranchesFromNpm(config) {
    const { 'dist-tags': distTags, time } = await npm_registry_1.fetchProjectNpmPackageInfo(config);
    const today = new Date();
    const active = [];
    const inactive = [];
    // Iterate through the NPM package information and determine active/inactive LTS versions with
    // their corresponding branches. We assume that an LTS tagged version in NPM belongs to the
    // last-minor branch of a given major (i.e. we assume there are no outdated LTS NPM dist tags).
    for (const npmDistTag in distTags) {
        if (isLtsDistTag(npmDistTag)) {
            const version = semver.parse(distTags[npmDistTag]);
            const branchName = `${version.major}.${version.minor}.x`;
            const majorReleaseDate = new Date(time[`${version.major}.0.0`]);
            const ltsEndDate = computeLtsEndDateOfMajor(majorReleaseDate);
            const ltsBranch = { name: branchName, version, npmDistTag };
            // Depending on whether the LTS phase is still active, add the branch
            // to the list of active or inactive LTS branches.
            if (today <= ltsEndDate) {
                active.push(ltsBranch);
            }
            else {
                inactive.push(ltsBranch);
            }
        }
    }
    // Sort LTS branches in descending order. i.e. most recent ones first.
    active.sort((a, b) => semver.rcompare(a.version, b.version));
    inactive.sort((a, b) => semver.rcompare(a.version, b.version));
    return { active, inactive };
}
exports.fetchLongTermSupportBranchesFromNpm = fetchLongTermSupportBranchesFromNpm;
/** Gets whether the specified tag corresponds to a LTS dist tag. */
function isLtsDistTag(tagName) {
    return ltsNpmDistTagRegex.test(tagName);
}
exports.isLtsDistTag = isLtsDistTag;
/**
 * Computes the date when long-term support ends for a major released at the
 * specified date.
 */
function computeLtsEndDateOfMajor(majorReleaseDate) {
    return new Date(majorReleaseDate.getFullYear(), majorReleaseDate.getMonth() + majorActiveSupportDuration + majorLongTermSupportDuration, majorReleaseDate.getDate(), majorReleaseDate.getHours(), majorReleaseDate.getMinutes(), majorReleaseDate.getSeconds(), majorReleaseDate.getMilliseconds());
}
exports.computeLtsEndDateOfMajor = computeLtsEndDateOfMajor;
/** Gets the long-term support NPM dist tag for a given major version. */
function getLtsNpmDistTagOfMajor(major) {
    // LTS versions should be tagged in NPM in the following format: `v{major}-lts`.
    return `v${major}-lts`;
}
exports.getLtsNpmDistTagOfMajor = getLtsNpmDistTagOfMajor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9uZy10ZXJtLXN1cHBvcnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9uZy1kZXYvcmVsZWFzZS92ZXJzaW9uaW5nL2xvbmctdGVybS1zdXBwb3J0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7OztBQUVILGlDQUFpQztBQUlqQyxpREFBMEQ7QUF1QjFEOzs7R0FHRztBQUNILE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxDQUFDO0FBRXJDOzs7R0FHRztBQUNILE1BQU0sNEJBQTRCLEdBQUcsRUFBRSxDQUFDO0FBRXhDLHlEQUF5RDtBQUN6RCxNQUFNLGtCQUFrQixHQUFHLGNBQWMsQ0FBQztBQUUxQyxpRkFBaUY7QUFDMUUsS0FBSyxVQUFVLG1DQUFtQyxDQUN2RCxNQUFxQjtJQUVyQixNQUFNLEVBQUMsV0FBVyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUMsR0FBRyxNQUFNLHlDQUEwQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQy9FLE1BQU0sS0FBSyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7SUFDekIsTUFBTSxNQUFNLEdBQWdCLEVBQUUsQ0FBQztJQUMvQixNQUFNLFFBQVEsR0FBZ0IsRUFBRSxDQUFDO0lBRWpDLDhGQUE4RjtJQUM5RiwyRkFBMkY7SUFDM0YsK0ZBQStGO0lBQy9GLEtBQUssTUFBTSxVQUFVLElBQUksUUFBUSxFQUFFO1FBQ2pDLElBQUksWUFBWSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzVCLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFFLENBQUM7WUFDcEQsTUFBTSxVQUFVLEdBQUcsR0FBRyxPQUFPLENBQUMsS0FBSyxJQUFJLE9BQU8sQ0FBQyxLQUFLLElBQUksQ0FBQztZQUN6RCxNQUFNLGdCQUFnQixHQUFHLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDaEUsTUFBTSxVQUFVLEdBQUcsd0JBQXdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUM5RCxNQUFNLFNBQVMsR0FBYyxFQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBQyxDQUFDO1lBQ3JFLHFFQUFxRTtZQUNyRSxrREFBa0Q7WUFDbEQsSUFBSSxLQUFLLElBQUksVUFBVSxFQUFFO2dCQUN2QixNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ3hCO2lCQUFNO2dCQUNMLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDMUI7U0FDRjtLQUNGO0lBRUQsc0VBQXNFO0lBQ3RFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDN0QsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUUvRCxPQUFPLEVBQUMsTUFBTSxFQUFFLFFBQVEsRUFBQyxDQUFDO0FBQzVCLENBQUM7QUFqQ0Qsa0ZBaUNDO0FBRUQsb0VBQW9FO0FBQ3BFLFNBQWdCLFlBQVksQ0FBQyxPQUFlO0lBQzFDLE9BQU8sa0JBQWtCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzFDLENBQUM7QUFGRCxvQ0FFQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLHdCQUF3QixDQUFDLGdCQUFzQjtJQUM3RCxPQUFPLElBQUksSUFBSSxDQUNiLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxFQUM5QixnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsRUFDdkYsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLEVBQzFCLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxFQUMzQixnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsRUFDN0IsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLEVBQzdCLGdCQUFnQixDQUFDLGVBQWUsRUFBRSxDQUNuQyxDQUFDO0FBQ0osQ0FBQztBQVZELDREQVVDO0FBRUQseUVBQXlFO0FBQ3pFLFNBQWdCLHVCQUF1QixDQUFDLEtBQWE7SUFDbkQsZ0ZBQWdGO0lBQ2hGLE9BQU8sSUFBSSxLQUFLLE1BQWUsQ0FBQztBQUNsQyxDQUFDO0FBSEQsMERBR0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmltcG9ydCB7UmVsZWFzZUNvbmZpZ30gZnJvbSAnLi4vY29uZmlnL2luZGV4JztcblxuaW1wb3J0IHtmZXRjaFByb2plY3ROcG1QYWNrYWdlSW5mb30gZnJvbSAnLi9ucG0tcmVnaXN0cnknO1xuXG4vKiogVHlwZSBkZXNjcmliaW5nIGEgTlBNIGRpc3QgdGFnIGluZGljYXRpbmcgbG9uZy10ZXJtIHN1cHBvcnQuICovXG5leHBvcnQgdHlwZSBMdHNOcG1EaXN0VGFnID0gYHYke251bWJlcn0tbHRzYDtcblxuLyoqIEludGVyZmFjZSBkZXNjcmliaW5nIGRldGVybWluZWQgTFRTIGJyYW5jaGVzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMdHNCcmFuY2hlcyB7XG4gIC8qKiBMaXN0IG9mIGFjdGl2ZSBMVFMgdmVyc2lvbiBicmFuY2hlcy4gKi9cbiAgYWN0aXZlOiBMdHNCcmFuY2hbXTtcbiAgLyoqIExpc3Qgb2YgaW5hY3RpdmUgTFRTIHZlcnNpb24gYnJhbmNoZXMuICovXG4gIGluYWN0aXZlOiBMdHNCcmFuY2hbXTtcbn1cblxuLyoqIEludGVyZmFjZSBkZXNjcmliaW5nIGFuIExUUyB2ZXJzaW9uIGJyYW5jaC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTHRzQnJhbmNoIHtcbiAgLyoqIE5hbWUgb2YgdGhlIGJyYW5jaC4gKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKiogTW9zdCByZWNlbnQgdmVyc2lvbiBmb3IgdGhlIGdpdmVuIExUUyBicmFuY2guICovXG4gIHZlcnNpb246IHNlbXZlci5TZW1WZXI7XG4gIC8qKiBOUE0gZGlzdCB0YWcgZm9yIHRoZSBMVFMgdmVyc2lvbi4gKi9cbiAgbnBtRGlzdFRhZzogTHRzTnBtRGlzdFRhZztcbn1cblxuLyoqXG4gKiBOdW1iZXIgb2YgbW9udGhzIGEgbWFqb3IgdmVyc2lvbiBpbiBBbmd1bGFyIGlzIGFjdGl2ZWx5IHN1cHBvcnRlZC4gU2VlOlxuICogaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL3JlbGVhc2VzI3N1cHBvcnQtcG9saWN5LWFuZC1zY2hlZHVsZS5cbiAqL1xuY29uc3QgbWFqb3JBY3RpdmVTdXBwb3J0RHVyYXRpb24gPSA2O1xuXG4vKipcbiAqIE51bWJlciBvZiBtb250aHMgYSBtYWpvciB2ZXJzaW9uIGhhcyBhY3RpdmUgbG9uZy10ZXJtIHN1cHBvcnQuIFNlZTpcbiAqIGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9yZWxlYXNlcyNzdXBwb3J0LXBvbGljeS1hbmQtc2NoZWR1bGUuXG4gKi9cbmNvbnN0IG1ham9yTG9uZ1Rlcm1TdXBwb3J0RHVyYXRpb24gPSAxMjtcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgTFRTIE5QTSBkaXN0IHRhZ3MuICovXG5jb25zdCBsdHNOcG1EaXN0VGFnUmVnZXggPSAvXnYoXFxkKyktbHRzJC87XG5cbi8qKiBGaW5kcyBhbGwgbG9uZy10ZXJtIHN1cHBvcnQgcmVsZWFzZSB0cmFpbnMgZnJvbSB0aGUgc3BlY2lmaWVkIE5QTSBwYWNrYWdlLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTG9uZ1Rlcm1TdXBwb3J0QnJhbmNoZXNGcm9tTnBtKFxuICBjb25maWc6IFJlbGVhc2VDb25maWcsXG4pOiBQcm9taXNlPEx0c0JyYW5jaGVzPiB7XG4gIGNvbnN0IHsnZGlzdC10YWdzJzogZGlzdFRhZ3MsIHRpbWV9ID0gYXdhaXQgZmV0Y2hQcm9qZWN0TnBtUGFja2FnZUluZm8oY29uZmlnKTtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCBhY3RpdmU6IEx0c0JyYW5jaFtdID0gW107XG4gIGNvbnN0IGluYWN0aXZlOiBMdHNCcmFuY2hbXSA9IFtdO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgTlBNIHBhY2thZ2UgaW5mb3JtYXRpb24gYW5kIGRldGVybWluZSBhY3RpdmUvaW5hY3RpdmUgTFRTIHZlcnNpb25zIHdpdGhcbiAgLy8gdGhlaXIgY29ycmVzcG9uZGluZyBicmFuY2hlcy4gV2UgYXNzdW1lIHRoYXQgYW4gTFRTIHRhZ2dlZCB2ZXJzaW9uIGluIE5QTSBiZWxvbmdzIHRvIHRoZVxuICAvLyBsYXN0LW1pbm9yIGJyYW5jaCBvZiBhIGdpdmVuIG1ham9yIChpLmUuIHdlIGFzc3VtZSB0aGVyZSBhcmUgbm8gb3V0ZGF0ZWQgTFRTIE5QTSBkaXN0IHRhZ3MpLlxuICBmb3IgKGNvbnN0IG5wbURpc3RUYWcgaW4gZGlzdFRhZ3MpIHtcbiAgICBpZiAoaXNMdHNEaXN0VGFnKG5wbURpc3RUYWcpKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gc2VtdmVyLnBhcnNlKGRpc3RUYWdzW25wbURpc3RUYWddKSE7XG4gICAgICBjb25zdCBicmFuY2hOYW1lID0gYCR7dmVyc2lvbi5tYWpvcn0uJHt2ZXJzaW9uLm1pbm9yfS54YDtcbiAgICAgIGNvbnN0IG1ham9yUmVsZWFzZURhdGUgPSBuZXcgRGF0ZSh0aW1lW2Ake3ZlcnNpb24ubWFqb3J9LjAuMGBdKTtcbiAgICAgIGNvbnN0IGx0c0VuZERhdGUgPSBjb21wdXRlTHRzRW5kRGF0ZU9mTWFqb3IobWFqb3JSZWxlYXNlRGF0ZSk7XG4gICAgICBjb25zdCBsdHNCcmFuY2g6IEx0c0JyYW5jaCA9IHtuYW1lOiBicmFuY2hOYW1lLCB2ZXJzaW9uLCBucG1EaXN0VGFnfTtcbiAgICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBMVFMgcGhhc2UgaXMgc3RpbGwgYWN0aXZlLCBhZGQgdGhlIGJyYW5jaFxuICAgICAgLy8gdG8gdGhlIGxpc3Qgb2YgYWN0aXZlIG9yIGluYWN0aXZlIExUUyBicmFuY2hlcy5cbiAgICAgIGlmICh0b2RheSA8PSBsdHNFbmREYXRlKSB7XG4gICAgICAgIGFjdGl2ZS5wdXNoKGx0c0JyYW5jaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmFjdGl2ZS5wdXNoKGx0c0JyYW5jaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU29ydCBMVFMgYnJhbmNoZXMgaW4gZGVzY2VuZGluZyBvcmRlci4gaS5lLiBtb3N0IHJlY2VudCBvbmVzIGZpcnN0LlxuICBhY3RpdmUuc29ydCgoYSwgYikgPT4gc2VtdmVyLnJjb21wYXJlKGEudmVyc2lvbiwgYi52ZXJzaW9uKSk7XG4gIGluYWN0aXZlLnNvcnQoKGEsIGIpID0+IHNlbXZlci5yY29tcGFyZShhLnZlcnNpb24sIGIudmVyc2lvbikpO1xuXG4gIHJldHVybiB7YWN0aXZlLCBpbmFjdGl2ZX07XG59XG5cbi8qKiBHZXRzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB0YWcgY29ycmVzcG9uZHMgdG8gYSBMVFMgZGlzdCB0YWcuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMdHNEaXN0VGFnKHRhZ05hbWU6IHN0cmluZyk6IHRhZ05hbWUgaXMgTHRzTnBtRGlzdFRhZyB7XG4gIHJldHVybiBsdHNOcG1EaXN0VGFnUmVnZXgudGVzdCh0YWdOYW1lKTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZGF0ZSB3aGVuIGxvbmctdGVybSBzdXBwb3J0IGVuZHMgZm9yIGEgbWFqb3IgcmVsZWFzZWQgYXQgdGhlXG4gKiBzcGVjaWZpZWQgZGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVMdHNFbmREYXRlT2ZNYWpvcihtYWpvclJlbGVhc2VEYXRlOiBEYXRlKTogRGF0ZSB7XG4gIHJldHVybiBuZXcgRGF0ZShcbiAgICBtYWpvclJlbGVhc2VEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgbWFqb3JSZWxlYXNlRGF0ZS5nZXRNb250aCgpICsgbWFqb3JBY3RpdmVTdXBwb3J0RHVyYXRpb24gKyBtYWpvckxvbmdUZXJtU3VwcG9ydER1cmF0aW9uLFxuICAgIG1ham9yUmVsZWFzZURhdGUuZ2V0RGF0ZSgpLFxuICAgIG1ham9yUmVsZWFzZURhdGUuZ2V0SG91cnMoKSxcbiAgICBtYWpvclJlbGVhc2VEYXRlLmdldE1pbnV0ZXMoKSxcbiAgICBtYWpvclJlbGVhc2VEYXRlLmdldFNlY29uZHMoKSxcbiAgICBtYWpvclJlbGVhc2VEYXRlLmdldE1pbGxpc2Vjb25kcygpLFxuICApO1xufVxuXG4vKiogR2V0cyB0aGUgbG9uZy10ZXJtIHN1cHBvcnQgTlBNIGRpc3QgdGFnIGZvciBhIGdpdmVuIG1ham9yIHZlcnNpb24uICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0THRzTnBtRGlzdFRhZ09mTWFqb3IobWFqb3I6IG51bWJlcik6IEx0c05wbURpc3RUYWcge1xuICAvLyBMVFMgdmVyc2lvbnMgc2hvdWxkIGJlIHRhZ2dlZCBpbiBOUE0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGB2e21ham9yfS1sdHNgLlxuICByZXR1cm4gYHYke21ham9yfS1sdHNgIGFzIGNvbnN0O1xufVxuIl19