"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLtsNpmDistTagOfMajor = exports.computeLtsEndDateOfMajor = exports.isLtsDistTag = exports.fetchLongTermSupportBranchesFromNpm = void 0;
const semver = require("semver");
const npm_registry_1 = require("./npm-registry");
/**
 * Number of months a major version in Angular is actively supported. See:
 * https://angular.io/guide/releases#support-policy-and-schedule.
 */
const majorActiveSupportDuration = 6;
/**
 * Number of months a major version has active long-term support. See:
 * https://angular.io/guide/releases#support-policy-and-schedule.
 */
const majorLongTermSupportDuration = 12;
/** Regular expression that matches LTS NPM dist tags. */
const ltsNpmDistTagRegex = /^v(\d+)-lts$/;
/** Finds all long-term support release trains from the specified NPM package. */
async function fetchLongTermSupportBranchesFromNpm(config) {
    const { 'dist-tags': distTags, time } = await (0, npm_registry_1.fetchProjectNpmPackageInfo)(config);
    const today = new Date();
    const active = [];
    const inactive = [];
    // Iterate through the NPM package information and determine active/inactive LTS versions with
    // their corresponding branches. We assume that an LTS tagged version in NPM belongs to the
    // last-minor branch of a given major (i.e. we assume there are no outdated LTS NPM dist tags).
    for (const npmDistTag in distTags) {
        if (isLtsDistTag(npmDistTag)) {
            const version = semver.parse(distTags[npmDistTag]);
            const branchName = `${version.major}.${version.minor}.x`;
            const majorReleaseDate = new Date(time[`${version.major}.0.0`]);
            const ltsEndDate = computeLtsEndDateOfMajor(majorReleaseDate);
            const ltsBranch = { name: branchName, version, npmDistTag };
            // Depending on whether the LTS phase is still active, add the branch
            // to the list of active or inactive LTS branches.
            if (today <= ltsEndDate) {
                active.push(ltsBranch);
            }
            else {
                inactive.push(ltsBranch);
            }
        }
    }
    // Sort LTS branches in descending order. i.e. most recent ones first.
    active.sort((a, b) => semver.rcompare(a.version, b.version));
    inactive.sort((a, b) => semver.rcompare(a.version, b.version));
    return { active, inactive };
}
exports.fetchLongTermSupportBranchesFromNpm = fetchLongTermSupportBranchesFromNpm;
/** Gets whether the specified tag corresponds to a LTS dist tag. */
function isLtsDistTag(tagName) {
    return ltsNpmDistTagRegex.test(tagName);
}
exports.isLtsDistTag = isLtsDistTag;
/**
 * Computes the date when long-term support ends for a major released at the
 * specified date.
 */
function computeLtsEndDateOfMajor(majorReleaseDate) {
    return new Date(majorReleaseDate.getFullYear(), majorReleaseDate.getMonth() + majorActiveSupportDuration + majorLongTermSupportDuration, majorReleaseDate.getDate(), majorReleaseDate.getHours(), majorReleaseDate.getMinutes(), majorReleaseDate.getSeconds(), majorReleaseDate.getMilliseconds());
}
exports.computeLtsEndDateOfMajor = computeLtsEndDateOfMajor;
/** Gets the long-term support NPM dist tag for a given major version. */
function getLtsNpmDistTagOfMajor(major) {
    // LTS versions should be tagged in NPM in the following format: `v{major}-lts`.
    return `v${major}-lts`;
}
exports.getLtsNpmDistTagOfMajor = getLtsNpmDistTagOfMajor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9uZy10ZXJtLXN1cHBvcnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9uZy1kZXYvcmVsZWFzZS92ZXJzaW9uaW5nL2xvbmctdGVybS1zdXBwb3J0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7OztBQUVILGlDQUFpQztBQUlqQyxpREFBMEQ7QUF1QjFEOzs7R0FHRztBQUNILE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxDQUFDO0FBRXJDOzs7R0FHRztBQUNILE1BQU0sNEJBQTRCLEdBQUcsRUFBRSxDQUFDO0FBRXhDLHlEQUF5RDtBQUN6RCxNQUFNLGtCQUFrQixHQUFHLGNBQWMsQ0FBQztBQUUxQyxpRkFBaUY7QUFDMUUsS0FBSyxVQUFVLG1DQUFtQyxDQUN2RCxNQUFxQjtJQUVyQixNQUFNLEVBQUMsV0FBVyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUMsR0FBRyxNQUFNLElBQUEseUNBQTBCLEVBQUMsTUFBTSxDQUFDLENBQUM7SUFDL0UsTUFBTSxLQUFLLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztJQUN6QixNQUFNLE1BQU0sR0FBZ0IsRUFBRSxDQUFDO0lBQy9CLE1BQU0sUUFBUSxHQUFnQixFQUFFLENBQUM7SUFFakMsOEZBQThGO0lBQzlGLDJGQUEyRjtJQUMzRiwrRkFBK0Y7SUFDL0YsS0FBSyxNQUFNLFVBQVUsSUFBSSxRQUFRLEVBQUU7UUFDakMsSUFBSSxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUUsQ0FBQztZQUNwRCxNQUFNLFVBQVUsR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxDQUFDO1lBQ3pELE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNoRSxNQUFNLFVBQVUsR0FBRyx3QkFBd0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQzlELE1BQU0sU0FBUyxHQUFjLEVBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFDLENBQUM7WUFDckUscUVBQXFFO1lBQ3JFLGtEQUFrRDtZQUNsRCxJQUFJLEtBQUssSUFBSSxVQUFVLEVBQUU7Z0JBQ3ZCLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDeEI7aUJBQU07Z0JBQ0wsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUMxQjtTQUNGO0tBQ0Y7SUFFRCxzRUFBc0U7SUFDdEUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUM3RCxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBRS9ELE9BQU8sRUFBQyxNQUFNLEVBQUUsUUFBUSxFQUFDLENBQUM7QUFDNUIsQ0FBQztBQWpDRCxrRkFpQ0M7QUFFRCxvRUFBb0U7QUFDcEUsU0FBZ0IsWUFBWSxDQUFDLE9BQWU7SUFDMUMsT0FBTyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDMUMsQ0FBQztBQUZELG9DQUVDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0Isd0JBQXdCLENBQUMsZ0JBQXNCO0lBQzdELE9BQU8sSUFBSSxJQUFJLENBQ2IsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLEVBQzlCLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxHQUFHLDBCQUEwQixHQUFHLDRCQUE0QixFQUN2RixnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsRUFDMUIsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLEVBQzNCLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxFQUM3QixnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsRUFDN0IsZ0JBQWdCLENBQUMsZUFBZSxFQUFFLENBQ25DLENBQUM7QUFDSixDQUFDO0FBVkQsNERBVUM7QUFFRCx5RUFBeUU7QUFDekUsU0FBZ0IsdUJBQXVCLENBQUMsS0FBYTtJQUNuRCxnRkFBZ0Y7SUFDaEYsT0FBTyxJQUFJLEtBQUssTUFBZSxDQUFDO0FBQ2xDLENBQUM7QUFIRCwwREFHQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuaW1wb3J0IHtSZWxlYXNlQ29uZmlnfSBmcm9tICcuLi9jb25maWcvaW5kZXgnO1xuXG5pbXBvcnQge2ZldGNoUHJvamVjdE5wbVBhY2thZ2VJbmZvfSBmcm9tICcuL25wbS1yZWdpc3RyeSc7XG5cbi8qKiBUeXBlIGRlc2NyaWJpbmcgYSBOUE0gZGlzdCB0YWcgaW5kaWNhdGluZyBsb25nLXRlcm0gc3VwcG9ydC4gKi9cbmV4cG9ydCB0eXBlIEx0c05wbURpc3RUYWcgPSBgdiR7bnVtYmVyfS1sdHNgO1xuXG4vKiogSW50ZXJmYWNlIGRlc2NyaWJpbmcgZGV0ZXJtaW5lZCBMVFMgYnJhbmNoZXMuICovXG5leHBvcnQgaW50ZXJmYWNlIEx0c0JyYW5jaGVzIHtcbiAgLyoqIExpc3Qgb2YgYWN0aXZlIExUUyB2ZXJzaW9uIGJyYW5jaGVzLiAqL1xuICBhY3RpdmU6IEx0c0JyYW5jaFtdO1xuICAvKiogTGlzdCBvZiBpbmFjdGl2ZSBMVFMgdmVyc2lvbiBicmFuY2hlcy4gKi9cbiAgaW5hY3RpdmU6IEx0c0JyYW5jaFtdO1xufVxuXG4vKiogSW50ZXJmYWNlIGRlc2NyaWJpbmcgYW4gTFRTIHZlcnNpb24gYnJhbmNoLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMdHNCcmFuY2gge1xuICAvKiogTmFtZSBvZiB0aGUgYnJhbmNoLiAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKiBNb3N0IHJlY2VudCB2ZXJzaW9uIGZvciB0aGUgZ2l2ZW4gTFRTIGJyYW5jaC4gKi9cbiAgdmVyc2lvbjogc2VtdmVyLlNlbVZlcjtcbiAgLyoqIE5QTSBkaXN0IHRhZyBmb3IgdGhlIExUUyB2ZXJzaW9uLiAqL1xuICBucG1EaXN0VGFnOiBMdHNOcG1EaXN0VGFnO1xufVxuXG4vKipcbiAqIE51bWJlciBvZiBtb250aHMgYSBtYWpvciB2ZXJzaW9uIGluIEFuZ3VsYXIgaXMgYWN0aXZlbHkgc3VwcG9ydGVkLiBTZWU6XG4gKiBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvcmVsZWFzZXMjc3VwcG9ydC1wb2xpY3ktYW5kLXNjaGVkdWxlLlxuICovXG5jb25zdCBtYWpvckFjdGl2ZVN1cHBvcnREdXJhdGlvbiA9IDY7XG5cbi8qKlxuICogTnVtYmVyIG9mIG1vbnRocyBhIG1ham9yIHZlcnNpb24gaGFzIGFjdGl2ZSBsb25nLXRlcm0gc3VwcG9ydC4gU2VlOlxuICogaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL3JlbGVhc2VzI3N1cHBvcnQtcG9saWN5LWFuZC1zY2hlZHVsZS5cbiAqL1xuY29uc3QgbWFqb3JMb25nVGVybVN1cHBvcnREdXJhdGlvbiA9IDEyO1xuXG4vKiogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBMVFMgTlBNIGRpc3QgdGFncy4gKi9cbmNvbnN0IGx0c05wbURpc3RUYWdSZWdleCA9IC9edihcXGQrKS1sdHMkLztcblxuLyoqIEZpbmRzIGFsbCBsb25nLXRlcm0gc3VwcG9ydCByZWxlYXNlIHRyYWlucyBmcm9tIHRoZSBzcGVjaWZpZWQgTlBNIHBhY2thZ2UuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hMb25nVGVybVN1cHBvcnRCcmFuY2hlc0Zyb21OcG0oXG4gIGNvbmZpZzogUmVsZWFzZUNvbmZpZyxcbik6IFByb21pc2U8THRzQnJhbmNoZXM+IHtcbiAgY29uc3QgeydkaXN0LXRhZ3MnOiBkaXN0VGFncywgdGltZX0gPSBhd2FpdCBmZXRjaFByb2plY3ROcG1QYWNrYWdlSW5mbyhjb25maWcpO1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IGFjdGl2ZTogTHRzQnJhbmNoW10gPSBbXTtcbiAgY29uc3QgaW5hY3RpdmU6IEx0c0JyYW5jaFtdID0gW107XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBOUE0gcGFja2FnZSBpbmZvcm1hdGlvbiBhbmQgZGV0ZXJtaW5lIGFjdGl2ZS9pbmFjdGl2ZSBMVFMgdmVyc2lvbnMgd2l0aFxuICAvLyB0aGVpciBjb3JyZXNwb25kaW5nIGJyYW5jaGVzLiBXZSBhc3N1bWUgdGhhdCBhbiBMVFMgdGFnZ2VkIHZlcnNpb24gaW4gTlBNIGJlbG9uZ3MgdG8gdGhlXG4gIC8vIGxhc3QtbWlub3IgYnJhbmNoIG9mIGEgZ2l2ZW4gbWFqb3IgKGkuZS4gd2UgYXNzdW1lIHRoZXJlIGFyZSBubyBvdXRkYXRlZCBMVFMgTlBNIGRpc3QgdGFncykuXG4gIGZvciAoY29uc3QgbnBtRGlzdFRhZyBpbiBkaXN0VGFncykge1xuICAgIGlmIChpc0x0c0Rpc3RUYWcobnBtRGlzdFRhZykpIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBzZW12ZXIucGFyc2UoZGlzdFRhZ3NbbnBtRGlzdFRhZ10pITtcbiAgICAgIGNvbnN0IGJyYW5jaE5hbWUgPSBgJHt2ZXJzaW9uLm1ham9yfS4ke3ZlcnNpb24ubWlub3J9LnhgO1xuICAgICAgY29uc3QgbWFqb3JSZWxlYXNlRGF0ZSA9IG5ldyBEYXRlKHRpbWVbYCR7dmVyc2lvbi5tYWpvcn0uMC4wYF0pO1xuICAgICAgY29uc3QgbHRzRW5kRGF0ZSA9IGNvbXB1dGVMdHNFbmREYXRlT2ZNYWpvcihtYWpvclJlbGVhc2VEYXRlKTtcbiAgICAgIGNvbnN0IGx0c0JyYW5jaDogTHRzQnJhbmNoID0ge25hbWU6IGJyYW5jaE5hbWUsIHZlcnNpb24sIG5wbURpc3RUYWd9O1xuICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIExUUyBwaGFzZSBpcyBzdGlsbCBhY3RpdmUsIGFkZCB0aGUgYnJhbmNoXG4gICAgICAvLyB0byB0aGUgbGlzdCBvZiBhY3RpdmUgb3IgaW5hY3RpdmUgTFRTIGJyYW5jaGVzLlxuICAgICAgaWYgKHRvZGF5IDw9IGx0c0VuZERhdGUpIHtcbiAgICAgICAgYWN0aXZlLnB1c2gobHRzQnJhbmNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluYWN0aXZlLnB1c2gobHRzQnJhbmNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTb3J0IExUUyBicmFuY2hlcyBpbiBkZXNjZW5kaW5nIG9yZGVyLiBpLmUuIG1vc3QgcmVjZW50IG9uZXMgZmlyc3QuXG4gIGFjdGl2ZS5zb3J0KChhLCBiKSA9PiBzZW12ZXIucmNvbXBhcmUoYS52ZXJzaW9uLCBiLnZlcnNpb24pKTtcbiAgaW5hY3RpdmUuc29ydCgoYSwgYikgPT4gc2VtdmVyLnJjb21wYXJlKGEudmVyc2lvbiwgYi52ZXJzaW9uKSk7XG5cbiAgcmV0dXJuIHthY3RpdmUsIGluYWN0aXZlfTtcbn1cblxuLyoqIEdldHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIHRhZyBjb3JyZXNwb25kcyB0byBhIExUUyBkaXN0IHRhZy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0x0c0Rpc3RUYWcodGFnTmFtZTogc3RyaW5nKTogdGFnTmFtZSBpcyBMdHNOcG1EaXN0VGFnIHtcbiAgcmV0dXJuIGx0c05wbURpc3RUYWdSZWdleC50ZXN0KHRhZ05hbWUpO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkYXRlIHdoZW4gbG9uZy10ZXJtIHN1cHBvcnQgZW5kcyBmb3IgYSBtYWpvciByZWxlYXNlZCBhdCB0aGVcbiAqIHNwZWNpZmllZCBkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUx0c0VuZERhdGVPZk1ham9yKG1ham9yUmVsZWFzZURhdGU6IERhdGUpOiBEYXRlIHtcbiAgcmV0dXJuIG5ldyBEYXRlKFxuICAgIG1ham9yUmVsZWFzZURhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICBtYWpvclJlbGVhc2VEYXRlLmdldE1vbnRoKCkgKyBtYWpvckFjdGl2ZVN1cHBvcnREdXJhdGlvbiArIG1ham9yTG9uZ1Rlcm1TdXBwb3J0RHVyYXRpb24sXG4gICAgbWFqb3JSZWxlYXNlRGF0ZS5nZXREYXRlKCksXG4gICAgbWFqb3JSZWxlYXNlRGF0ZS5nZXRIb3VycygpLFxuICAgIG1ham9yUmVsZWFzZURhdGUuZ2V0TWludXRlcygpLFxuICAgIG1ham9yUmVsZWFzZURhdGUuZ2V0U2Vjb25kcygpLFxuICAgIG1ham9yUmVsZWFzZURhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICk7XG59XG5cbi8qKiBHZXRzIHRoZSBsb25nLXRlcm0gc3VwcG9ydCBOUE0gZGlzdCB0YWcgZm9yIGEgZ2l2ZW4gbWFqb3IgdmVyc2lvbi4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMdHNOcG1EaXN0VGFnT2ZNYWpvcihtYWpvcjogbnVtYmVyKTogTHRzTnBtRGlzdFRhZyB7XG4gIC8vIExUUyB2ZXJzaW9ucyBzaG91bGQgYmUgdGFnZ2VkIGluIE5QTSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogYHZ7bWFqb3J9LWx0c2AuXG4gIHJldHVybiBgdiR7bWFqb3J9LWx0c2AgYXMgY29uc3Q7XG59XG4iXX0=