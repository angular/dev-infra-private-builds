"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BranchOffNextBranchBaseAction = void 0;
const semver = require("semver");
const console_1 = require("../../../utils/console");
const semver_1 = require("../../../utils/semver");
const release_notes_1 = require("../../notes/release-notes");
const next_prerelease_version_1 = require("../../versioning/next-prerelease-version");
const actions_1 = require("../actions");
const commit_message_1 = require("../commit-message");
const constants_1 = require("../../../utils/constants");
/**
 * Base action that can be used to move the next release-train into the feature-freeze or
 * release-candidate phase. This means that a new version branch is created from the next
 * branch, and a new pre-release (either RC or another `next`) is cut indicating the new phase.
 */
class BranchOffNextBranchBaseAction extends actions_1.ReleaseAction {
    async getDescription() {
        const { branchName } = this.active.next;
        const newVersion = await this._computeNewVersion();
        return `Move the "${branchName}" branch into ${this.newPhaseName} phase (v${newVersion}).`;
    }
    async perform() {
        const compareVersionForReleaseNotes = await (0, next_prerelease_version_1.getReleaseNotesCompareVersionForNext)(this.active, this.config);
        const newVersion = await this._computeNewVersion();
        const newBranch = `${newVersion.major}.${newVersion.minor}.x`;
        // Branch-off the next branch into a new version branch.
        await this._createNewVersionBranchFromNext(newBranch);
        // Stage the new version for the newly created branch, and push changes to a
        // fork in order to create a staging pull request. Note that we re-use the newly
        // created branch instead of re-fetching from the upstream.
        const { pullRequest, releaseNotes } = await this.stageVersionForBranchAndCreatePullRequest(newVersion, compareVersionForReleaseNotes, newBranch);
        // Wait for the staging PR to be merged. Then build and publish the feature-freeze next
        // pre-release. Finally, cherry-pick the release notes into the next branch in combination
        // with bumping the version to the next minor too.
        await this.waitForPullRequestToBeMerged(pullRequest);
        await this.buildAndPublish(releaseNotes, newBranch, 'next');
        await this._createNextBranchUpdatePullRequest(releaseNotes, newVersion);
    }
    /** Computes the new version for the release-train being branched-off. */
    async _computeNewVersion() {
        if (this.newPhaseName === 'feature-freeze') {
            return (0, next_prerelease_version_1.computeNewPrereleaseVersionForNext)(this.active, this.config);
        }
        else {
            return (0, semver_1.semverInc)(this.active.next.version, 'prerelease', 'rc');
        }
    }
    /** Creates a new version branch from the next branch. */
    async _createNewVersionBranchFromNext(newBranch) {
        const { branchName: nextBranch } = this.active.next;
        await this.verifyPassingGithubStatus(nextBranch);
        await this.checkoutUpstreamBranch(nextBranch);
        await this.createLocalBranchFromHead(newBranch);
        await this.pushHeadToRemoteBranch(newBranch);
        (0, console_1.info)((0, console_1.green)(`  ✓   Version branch "${newBranch}" created.`));
    }
    /**
     * Creates a pull request for the next branch that bumps the version to the next
     * minor, and cherry-picks the changelog for the newly branched-off release-candidate
     * or feature-freeze version.
     */
    async _createNextBranchUpdatePullRequest(releaseNotes, newVersion) {
        const { branchName: nextBranch, version } = this.active.next;
        // We increase the version for the next branch to the next minor. The team can decide
        // later if they want next to be a major through the `Configure Next as Major` release action.
        const newNextVersion = semver.parse(`${version.major}.${version.minor + 1}.0-next.0`);
        const bumpCommitMessage = (0, commit_message_1.getCommitMessageForExceptionalNextVersionBump)(newNextVersion);
        await this.checkoutUpstreamBranch(nextBranch);
        await this.updateProjectVersion(newNextVersion);
        // Create an individual commit for the next version bump. The changelog should go into
        // a separate commit that makes it clear where the changelog is cherry-picked from.
        await this.createCommit(bumpCommitMessage, [constants_1.workspaceRelativePackageJsonPath]);
        await this.prependReleaseNotesToChangelog(releaseNotes);
        const commitMessage = (0, commit_message_1.getReleaseNoteCherryPickCommitMessage)(releaseNotes.version);
        await this.createCommit(commitMessage, [release_notes_1.workspaceRelativeChangelogPath]);
        let nextPullRequestMessage = `The previous "next" release-train has moved into the ` +
            `${this.newPhaseName} phase. This PR updates the next branch to the subsequent ` +
            `release-train.\n\nAlso this PR cherry-picks the changelog for ` +
            `v${newVersion} into the ${nextBranch} branch so that the changelog is up to date.`;
        const nextUpdatePullRequest = await this.pushChangesToForkAndCreatePullRequest(nextBranch, `next-release-train-${newNextVersion}`, `Update next branch to reflect new release-train "v${newNextVersion}".`, nextPullRequestMessage);
        (0, console_1.info)((0, console_1.green)(`  ✓   Pull request for updating the "${nextBranch}" branch has been created.`));
        (0, console_1.info)((0, console_1.yellow)(`      Please ask team members to review: ${nextUpdatePullRequest.url}.`));
    }
}
exports.BranchOffNextBranchBaseAction = BranchOffNextBranchBaseAction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJhbmNoLW9mZi1uZXh0LWJyYW5jaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL25nLWRldi9yZWxlYXNlL3B1Ymxpc2gvYWN0aW9ucy9icmFuY2gtb2ZmLW5leHQtYnJhbmNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7OztBQUVILGlDQUFpQztBQUVqQyxvREFBMkQ7QUFDM0Qsa0RBQWdEO0FBQ2hELDZEQUF1RjtBQUN2RixzRkFHa0Q7QUFDbEQsd0NBQXlDO0FBQ3pDLHNEQUcyQjtBQUMzQix3REFBMEU7QUFFMUU7Ozs7R0FJRztBQUNILE1BQXNCLDZCQUE4QixTQUFRLHVCQUFhO0lBVTlELEtBQUssQ0FBQyxjQUFjO1FBQzNCLE1BQU0sRUFBQyxVQUFVLEVBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztRQUN0QyxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQ25ELE9BQU8sYUFBYSxVQUFVLGlCQUFpQixJQUFJLENBQUMsWUFBWSxZQUFZLFVBQVUsSUFBSSxDQUFDO0lBQzdGLENBQUM7SUFFUSxLQUFLLENBQUMsT0FBTztRQUNwQixNQUFNLDZCQUE2QixHQUFHLE1BQU0sSUFBQSw4REFBb0MsRUFDOUUsSUFBSSxDQUFDLE1BQU0sRUFDWCxJQUFJLENBQUMsTUFBTSxDQUNaLENBQUM7UUFDRixNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQ25ELE1BQU0sU0FBUyxHQUFHLEdBQUcsVUFBVSxDQUFDLEtBQUssSUFBSSxVQUFVLENBQUMsS0FBSyxJQUFJLENBQUM7UUFFOUQsd0RBQXdEO1FBQ3hELE1BQU0sSUFBSSxDQUFDLCtCQUErQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXRELDRFQUE0RTtRQUM1RSxnRkFBZ0Y7UUFDaEYsMkRBQTJEO1FBQzNELE1BQU0sRUFB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QixHQUFHLE1BQU0sSUFBSSxDQUFDLHFDQUFxQyxDQUM1RSxVQUFVLEVBQ1Ysc0JBQXNCLGNBQWMsRUFBRSxFQUN0QyxxREFBcUQsY0FBYyxJQUFJLEVBQ3ZFLHNCQUFzQixDQUN2QixDQUFDO1FBRUYsSUFBQSxjQUFJLEVBQUMsSUFBQSxlQUFLLEVBQUMsd0NBQXdDLFVBQVUsNEJBQTRCLENBQUMsQ0FBQyxDQUFDO1FBQzVGLElBQUEsY0FBSSxFQUFDLElBQUEsZ0JBQU0sRUFBQyw0Q0FBNEMscUJBQXFCLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7Q0FDRjtBQTNHRCxzRUEyR0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5cbmltcG9ydCB7Z3JlZW4sIGluZm8sIHllbGxvd30gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY29uc29sZSc7XG5pbXBvcnQge3NlbXZlckluY30gZnJvbSAnLi4vLi4vLi4vdXRpbHMvc2VtdmVyJztcbmltcG9ydCB7UmVsZWFzZU5vdGVzLCB3b3Jrc3BhY2VSZWxhdGl2ZUNoYW5nZWxvZ1BhdGh9IGZyb20gJy4uLy4uL25vdGVzL3JlbGVhc2Utbm90ZXMnO1xuaW1wb3J0IHtcbiAgY29tcHV0ZU5ld1ByZXJlbGVhc2VWZXJzaW9uRm9yTmV4dCxcbiAgZ2V0UmVsZWFzZU5vdGVzQ29tcGFyZVZlcnNpb25Gb3JOZXh0LFxufSBmcm9tICcuLi8uLi92ZXJzaW9uaW5nL25leHQtcHJlcmVsZWFzZS12ZXJzaW9uJztcbmltcG9ydCB7UmVsZWFzZUFjdGlvbn0gZnJvbSAnLi4vYWN0aW9ucyc7XG5pbXBvcnQge1xuICBnZXRDb21taXRNZXNzYWdlRm9yRXhjZXB0aW9uYWxOZXh0VmVyc2lvbkJ1bXAsXG4gIGdldFJlbGVhc2VOb3RlQ2hlcnJ5UGlja0NvbW1pdE1lc3NhZ2UsXG59IGZyb20gJy4uL2NvbW1pdC1tZXNzYWdlJztcbmltcG9ydCB7d29ya3NwYWNlUmVsYXRpdmVQYWNrYWdlSnNvblBhdGh9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQmFzZSBhY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBtb3ZlIHRoZSBuZXh0IHJlbGVhc2UtdHJhaW4gaW50byB0aGUgZmVhdHVyZS1mcmVlemUgb3JcbiAqIHJlbGVhc2UtY2FuZGlkYXRlIHBoYXNlLiBUaGlzIG1lYW5zIHRoYXQgYSBuZXcgdmVyc2lvbiBicmFuY2ggaXMgY3JlYXRlZCBmcm9tIHRoZSBuZXh0XG4gKiBicmFuY2gsIGFuZCBhIG5ldyBwcmUtcmVsZWFzZSAoZWl0aGVyIFJDIG9yIGFub3RoZXIgYG5leHRgKSBpcyBjdXQgaW5kaWNhdGluZyB0aGUgbmV3IHBoYXNlLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQnJhbmNoT2ZmTmV4dEJyYW5jaEJhc2VBY3Rpb24gZXh0ZW5kcyBSZWxlYXNlQWN0aW9uIHtcbiAgLyoqXG4gICAqIFBoYXNlIHdoaWNoIHRoZSByZWxlYXNlLXRyYWluIGN1cnJlbnRseSBpbiB0aGUgYG5leHRgIHBoYXNlIHdpbGwgbW92ZSBpbnRvLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgd2Ugb25seSBhbGxvdyBmb3IgYSBuZXh0IHZlcnNpb24gdG8gYnJhbmNoIGludG8gZmVhdHVyZS1mcmVlemUgb3JcbiAgICogZGlyZWN0bHkgaW50byB0aGUgcmVsZWFzZS1jYW5kaWRhdGUgcGhhc2UuIEEgc3RhYmxlIHZlcnNpb24gY2Fubm90IGJlIHJlbGVhc2VkXG4gICAqIHdpdGhvdXQgcmVsZWFzZS1jYW5kaWRhdGUuXG4gICAqL1xuICBhYnN0cmFjdCBuZXdQaGFzZU5hbWU6ICdmZWF0dXJlLWZyZWV6ZScgfCAncmVsZWFzZS1jYW5kaWRhdGUnO1xuXG4gIG92ZXJyaWRlIGFzeW5jIGdldERlc2NyaXB0aW9uKCkge1xuICAgIGNvbnN0IHticmFuY2hOYW1lfSA9IHRoaXMuYWN0aXZlLm5leHQ7XG4gICAgY29uc3QgbmV3VmVyc2lvbiA9IGF3YWl0IHRoaXMuX2NvbXB1dGVOZXdWZXJzaW9uKCk7XG4gICAgcmV0dXJuIGBNb3ZlIHRoZSBcIiR7YnJhbmNoTmFtZX1cIiBicmFuY2ggaW50byAke3RoaXMubmV3UGhhc2VOYW1lfSBwaGFzZSAodiR7bmV3VmVyc2lvbn0pLmA7XG4gIH1cblxuICBvdmVycmlkZSBhc3luYyBwZXJmb3JtKCkge1xuICAgIGNvbnN0IGNvbXBhcmVWZXJzaW9uRm9yUmVsZWFzZU5vdGVzID0gYXdhaXQgZ2V0UmVsZWFzZU5vdGVzQ29tcGFyZVZlcnNpb25Gb3JOZXh0KFxuICAgICAgdGhpcy5hY3RpdmUsXG4gICAgICB0aGlzLmNvbmZpZyxcbiAgICApO1xuICAgIGNvbnN0IG5ld1ZlcnNpb24gPSBhd2FpdCB0aGlzLl9jb21wdXRlTmV3VmVyc2lvbigpO1xuICAgIGNvbnN0IG5ld0JyYW5jaCA9IGAke25ld1ZlcnNpb24ubWFqb3J9LiR7bmV3VmVyc2lvbi5taW5vcn0ueGA7XG5cbiAgICAvLyBCcmFuY2gtb2ZmIHRoZSBuZXh0IGJyYW5jaCBpbnRvIGEgbmV3IHZlcnNpb24gYnJhbmNoLlxuICAgIGF3YWl0IHRoaXMuX2NyZWF0ZU5ld1ZlcnNpb25CcmFuY2hGcm9tTmV4dChuZXdCcmFuY2gpO1xuXG4gICAgLy8gU3RhZ2UgdGhlIG5ldyB2ZXJzaW9uIGZvciB0aGUgbmV3bHkgY3JlYXRlZCBicmFuY2gsIGFuZCBwdXNoIGNoYW5nZXMgdG8gYVxuICAgIC8vIGZvcmsgaW4gb3JkZXIgdG8gY3JlYXRlIGEgc3RhZ2luZyBwdWxsIHJlcXVlc3QuIE5vdGUgdGhhdCB3ZSByZS11c2UgdGhlIG5ld2x5XG4gICAgLy8gY3JlYXRlZCBicmFuY2ggaW5zdGVhZCBvZiByZS1mZXRjaGluZyBmcm9tIHRoZSB1cHN0cmVhbS5cbiAgICBjb25zdCB7cHVsbFJlcXVlc3QsIHJlbGVhc2VOb3Rlc30gPSBhd2FpdCB0aGlzLnN0YWdlVmVyc2lvbkZvckJyYW5jaEFuZENyZWF0ZVB1bGxSZXF1ZXN0KFxuICAgICAgbmV3VmVyc2lvbixcbiAgICAgIGNvbXBhcmVWZXJzaW9uRm9yUmVsZWFzZU5vdGVzLFxuICAgICAgbmV3QnJhbmNoLFxuICAgICk7XG5cbiAgICAvLyBXYWl0IGZvciB0aGUgc3RhZ2luZyBQUiB0byBiZSBtZXJnZWQuIFRoZW4gYnVpbGQgYW5kIHB1Ymxpc2ggdGhlIGZlYXR1cmUtZnJlZXplIG5leHRcbiAgICAvLyBwcmUtcmVsZWFzZS4gRmluYWxseSwgY2hlcnJ5LXBpY2sgdGhlIHJlbGVhc2Ugbm90ZXMgaW50byB0aGUgbmV4dCBicmFuY2ggaW4gY29tYmluYXRpb25cbiAgICAvLyB3aXRoIGJ1bXBpbmcgdGhlIHZlcnNpb24gdG8gdGhlIG5leHQgbWlub3IgdG9vLlxuICAgIGF3YWl0IHRoaXMud2FpdEZvclB1bGxSZXF1ZXN0VG9CZU1lcmdlZChwdWxsUmVxdWVzdCk7XG4gICAgYXdhaXQgdGhpcy5idWlsZEFuZFB1Ymxpc2gocmVsZWFzZU5vdGVzLCBuZXdCcmFuY2gsICduZXh0Jyk7XG4gICAgYXdhaXQgdGhpcy5fY3JlYXRlTmV4dEJyYW5jaFVwZGF0ZVB1bGxSZXF1ZXN0KHJlbGVhc2VOb3RlcywgbmV3VmVyc2lvbik7XG4gIH1cblxuICAvKiogQ29tcHV0ZXMgdGhlIG5ldyB2ZXJzaW9uIGZvciB0aGUgcmVsZWFzZS10cmFpbiBiZWluZyBicmFuY2hlZC1vZmYuICovXG4gIHByaXZhdGUgYXN5bmMgX2NvbXB1dGVOZXdWZXJzaW9uKCkge1xuICAgIGlmICh0aGlzLm5ld1BoYXNlTmFtZSA9PT0gJ2ZlYXR1cmUtZnJlZXplJykge1xuICAgICAgcmV0dXJuIGNvbXB1dGVOZXdQcmVyZWxlYXNlVmVyc2lvbkZvck5leHQodGhpcy5hY3RpdmUsIHRoaXMuY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbXZlckluYyh0aGlzLmFjdGl2ZS5uZXh0LnZlcnNpb24sICdwcmVyZWxlYXNlJywgJ3JjJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENyZWF0ZXMgYSBuZXcgdmVyc2lvbiBicmFuY2ggZnJvbSB0aGUgbmV4dCBicmFuY2guICovXG4gIHByaXZhdGUgYXN5bmMgX2NyZWF0ZU5ld1ZlcnNpb25CcmFuY2hGcm9tTmV4dChuZXdCcmFuY2g6IHN0cmluZykge1xuICAgIGNvbnN0IHticmFuY2hOYW1lOiBuZXh0QnJhbmNofSA9IHRoaXMuYWN0aXZlLm5leHQ7XG4gICAgYXdhaXQgdGhpcy52ZXJpZnlQYXNzaW5nR2l0aHViU3RhdHVzKG5leHRCcmFuY2gpO1xuICAgIGF3YWl0IHRoaXMuY2hlY2tvdXRVcHN0cmVhbUJyYW5jaChuZXh0QnJhbmNoKTtcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZUxvY2FsQnJhbmNoRnJvbUhlYWQobmV3QnJhbmNoKTtcbiAgICBhd2FpdCB0aGlzLnB1c2hIZWFkVG9SZW1vdGVCcmFuY2gobmV3QnJhbmNoKTtcbiAgICBpbmZvKGdyZWVuKGAgIOKckyAgIFZlcnNpb24gYnJhbmNoIFwiJHtuZXdCcmFuY2h9XCIgY3JlYXRlZC5gKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHB1bGwgcmVxdWVzdCBmb3IgdGhlIG5leHQgYnJhbmNoIHRoYXQgYnVtcHMgdGhlIHZlcnNpb24gdG8gdGhlIG5leHRcbiAgICogbWlub3IsIGFuZCBjaGVycnktcGlja3MgdGhlIGNoYW5nZWxvZyBmb3IgdGhlIG5ld2x5IGJyYW5jaGVkLW9mZiByZWxlYXNlLWNhbmRpZGF0ZVxuICAgKiBvciBmZWF0dXJlLWZyZWV6ZSB2ZXJzaW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfY3JlYXRlTmV4dEJyYW5jaFVwZGF0ZVB1bGxSZXF1ZXN0KFxuICAgIHJlbGVhc2VOb3RlczogUmVsZWFzZU5vdGVzLFxuICAgIG5ld1ZlcnNpb246IHNlbXZlci5TZW1WZXIsXG4gICkge1xuICAgIGNvbnN0IHticmFuY2hOYW1lOiBuZXh0QnJhbmNoLCB2ZXJzaW9ufSA9IHRoaXMuYWN0aXZlLm5leHQ7XG4gICAgLy8gV2UgaW5jcmVhc2UgdGhlIHZlcnNpb24gZm9yIHRoZSBuZXh0IGJyYW5jaCB0byB0aGUgbmV4dCBtaW5vci4gVGhlIHRlYW0gY2FuIGRlY2lkZVxuICAgIC8vIGxhdGVyIGlmIHRoZXkgd2FudCBuZXh0IHRvIGJlIGEgbWFqb3IgdGhyb3VnaCB0aGUgYENvbmZpZ3VyZSBOZXh0IGFzIE1ham9yYCByZWxlYXNlIGFjdGlvbi5cbiAgICBjb25zdCBuZXdOZXh0VmVyc2lvbiA9IHNlbXZlci5wYXJzZShgJHt2ZXJzaW9uLm1ham9yfS4ke3ZlcnNpb24ubWlub3IgKyAxfS4wLW5leHQuMGApITtcbiAgICBjb25zdCBidW1wQ29tbWl0TWVzc2FnZSA9IGdldENvbW1pdE1lc3NhZ2VGb3JFeGNlcHRpb25hbE5leHRWZXJzaW9uQnVtcChuZXdOZXh0VmVyc2lvbik7XG5cbiAgICBhd2FpdCB0aGlzLmNoZWNrb3V0VXBzdHJlYW1CcmFuY2gobmV4dEJyYW5jaCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVQcm9qZWN0VmVyc2lvbihuZXdOZXh0VmVyc2lvbik7XG5cbiAgICAvLyBDcmVhdGUgYW4gaW5kaXZpZHVhbCBjb21taXQgZm9yIHRoZSBuZXh0IHZlcnNpb24gYnVtcC4gVGhlIGNoYW5nZWxvZyBzaG91bGQgZ28gaW50b1xuICAgIC8vIGEgc2VwYXJhdGUgY29tbWl0IHRoYXQgbWFrZXMgaXQgY2xlYXIgd2hlcmUgdGhlIGNoYW5nZWxvZyBpcyBjaGVycnktcGlja2VkIGZyb20uXG4gICAgYXdhaXQgdGhpcy5jcmVhdGVDb21taXQoYnVtcENvbW1pdE1lc3NhZ2UsIFt3b3Jrc3BhY2VSZWxhdGl2ZVBhY2thZ2VKc29uUGF0aF0pO1xuXG4gICAgYXdhaXQgdGhpcy5wcmVwZW5kUmVsZWFzZU5vdGVzVG9DaGFuZ2Vsb2cocmVsZWFzZU5vdGVzKTtcblxuICAgIGNvbnN0IGNvbW1pdE1lc3NhZ2UgPSBnZXRSZWxlYXNlTm90ZUNoZXJyeVBpY2tDb21taXRNZXNzYWdlKHJlbGVhc2VOb3Rlcy52ZXJzaW9uKTtcblxuICAgIGF3YWl0IHRoaXMuY3JlYXRlQ29tbWl0KGNvbW1pdE1lc3NhZ2UsIFt3b3Jrc3BhY2VSZWxhdGl2ZUNoYW5nZWxvZ1BhdGhdKTtcblxuICAgIGxldCBuZXh0UHVsbFJlcXVlc3RNZXNzYWdlID1cbiAgICAgIGBUaGUgcHJldmlvdXMgXCJuZXh0XCIgcmVsZWFzZS10cmFpbiBoYXMgbW92ZWQgaW50byB0aGUgYCArXG4gICAgICBgJHt0aGlzLm5ld1BoYXNlTmFtZX0gcGhhc2UuIFRoaXMgUFIgdXBkYXRlcyB0aGUgbmV4dCBicmFuY2ggdG8gdGhlIHN1YnNlcXVlbnQgYCArXG4gICAgICBgcmVsZWFzZS10cmFpbi5cXG5cXG5BbHNvIHRoaXMgUFIgY2hlcnJ5LXBpY2tzIHRoZSBjaGFuZ2Vsb2cgZm9yIGAgK1xuICAgICAgYHYke25ld1ZlcnNpb259IGludG8gdGhlICR7bmV4dEJyYW5jaH0gYnJhbmNoIHNvIHRoYXQgdGhlIGNoYW5nZWxvZyBpcyB1cCB0byBkYXRlLmA7XG5cbiAgICBjb25zdCBuZXh0VXBkYXRlUHVsbFJlcXVlc3QgPSBhd2FpdCB0aGlzLnB1c2hDaGFuZ2VzVG9Gb3JrQW5kQ3JlYXRlUHVsbFJlcXVlc3QoXG4gICAgICBuZXh0QnJhbmNoLFxuICAgICAgYG5leHQtcmVsZWFzZS10cmFpbi0ke25ld05leHRWZXJzaW9ufWAsXG4gICAgICBgVXBkYXRlIG5leHQgYnJhbmNoIHRvIHJlZmxlY3QgbmV3IHJlbGVhc2UtdHJhaW4gXCJ2JHtuZXdOZXh0VmVyc2lvbn1cIi5gLFxuICAgICAgbmV4dFB1bGxSZXF1ZXN0TWVzc2FnZSxcbiAgICApO1xuXG4gICAgaW5mbyhncmVlbihgICDinJMgICBQdWxsIHJlcXVlc3QgZm9yIHVwZGF0aW5nIHRoZSBcIiR7bmV4dEJyYW5jaH1cIiBicmFuY2ggaGFzIGJlZW4gY3JlYXRlZC5gKSk7XG4gICAgaW5mbyh5ZWxsb3coYCAgICAgIFBsZWFzZSBhc2sgdGVhbSBtZW1iZXJzIHRvIHJldmlldzogJHtuZXh0VXBkYXRlUHVsbFJlcXVlc3QudXJsfS5gKSk7XG4gIH1cbn1cbiJdfQ==