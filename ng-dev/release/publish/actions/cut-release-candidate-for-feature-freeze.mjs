"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CutReleaseCandidateForFeatureFreezeAction = void 0;
const semver_1 = require("../../../utils/semver");
const actions_1 = require("../actions");
/**
 * Cuts the first release candidate for a release-train currently in the
 * feature-freeze phase. The version is bumped from `next` to `rc.0`.
 */
class CutReleaseCandidateForFeatureFreezeAction extends actions_1.ReleaseAction {
    constructor() {
        super(...arguments);
        this._newVersion = (0, semver_1.semverInc)(this.active.releaseCandidate.version, 'prerelease', 'rc');
    }
    async getDescription() {
        const newVersion = this._newVersion;
        return `Cut a first release-candidate for the feature-freeze branch (v${newVersion}).`;
    }
    async perform() {
        const { branchName } = this.active.releaseCandidate;
        const newVersion = this._newVersion;
        const compareVersionForReleaseNotes = this.active.releaseCandidate.version;
        const { pullRequest, releaseNotes } = await this.checkoutBranchAndStageVersion(newVersion, compareVersionForReleaseNotes, branchName);
        await this.waitForPullRequestToBeMerged(pullRequest);
        await this.buildAndPublish(releaseNotes, branchName, 'next');
        await this.cherryPickChangelogIntoNextBranch(releaseNotes, branchName);
    }
    static async isActive(active) {
        // A release-candidate can be cut for an active release-train currently
        // in the feature-freeze phase.
        return (active.releaseCandidate !== null && active.releaseCandidate.version.prerelease[0] === 'next');
    }
}
exports.CutReleaseCandidateForFeatureFreezeAction = CutReleaseCandidateForFeatureFreezeAction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3V0LXJlbGVhc2UtY2FuZGlkYXRlLWZvci1mZWF0dXJlLWZyZWV6ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL25nLWRldi9yZWxlYXNlL3B1Ymxpc2gvYWN0aW9ucy9jdXQtcmVsZWFzZS1jYW5kaWRhdGUtZm9yLWZlYXR1cmUtZnJlZXplLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7OztBQUVILGtEQUFnRDtBQUVoRCx3Q0FBeUM7QUFFekM7OztHQUdHO0FBQ0gsTUFBYSx5Q0FBMEMsU0FBUSx1QkFBYTtJQUE1RTs7UUFDVSxnQkFBVyxHQUFHLElBQUEsa0JBQVMsRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFpQixDQUFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7SUE4QjdGLENBQUM7SUE1QlUsS0FBSyxDQUFDLGNBQWM7UUFDM0IsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUNwQyxPQUFPLGlFQUFpRSxVQUFVLElBQUksQ0FBQztJQUN6RixDQUFDO0lBRVEsS0FBSyxDQUFDLE9BQU87UUFDcEIsTUFBTSxFQUFDLFVBQVUsRUFBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWlCLENBQUM7UUFDbkQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUNwQyxNQUFNLDZCQUE2QixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWlCLENBQUMsT0FBTyxDQUFDO1FBRTVFLE1BQU0sRUFBQyxXQUFXLEVBQUUsWUFBWSxFQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsNkJBQTZCLENBQzFFLFVBQVUsRUFDViw2QkFBNkIsRUFDN0IsVUFBVSxDQUNYLENBQUM7UUFFRixNQUFNLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNyRCxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUM3RCxNQUFNLElBQUksQ0FBQyxpQ0FBaUMsQ0FBQyxZQUFZLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVELE1BQU0sQ0FBVSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQTJCO1FBQ3hELHVFQUF1RTtRQUN2RSwrQkFBK0I7UUFDL0IsT0FBTyxDQUNMLE1BQU0sQ0FBQyxnQkFBZ0IsS0FBSyxJQUFJLElBQUksTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUM3RixDQUFDO0lBQ0osQ0FBQztDQUNGO0FBL0JELDhGQStCQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge3NlbXZlckluY30gZnJvbSAnLi4vLi4vLi4vdXRpbHMvc2VtdmVyJztcbmltcG9ydCB7QWN0aXZlUmVsZWFzZVRyYWluc30gZnJvbSAnLi4vLi4vdmVyc2lvbmluZy9hY3RpdmUtcmVsZWFzZS10cmFpbnMnO1xuaW1wb3J0IHtSZWxlYXNlQWN0aW9ufSBmcm9tICcuLi9hY3Rpb25zJztcblxuLyoqXG4gKiBDdXRzIHRoZSBmaXJzdCByZWxlYXNlIGNhbmRpZGF0ZSBmb3IgYSByZWxlYXNlLXRyYWluIGN1cnJlbnRseSBpbiB0aGVcbiAqIGZlYXR1cmUtZnJlZXplIHBoYXNlLiBUaGUgdmVyc2lvbiBpcyBidW1wZWQgZnJvbSBgbmV4dGAgdG8gYHJjLjBgLlxuICovXG5leHBvcnQgY2xhc3MgQ3V0UmVsZWFzZUNhbmRpZGF0ZUZvckZlYXR1cmVGcmVlemVBY3Rpb24gZXh0ZW5kcyBSZWxlYXNlQWN0aW9uIHtcbiAgcHJpdmF0ZSBfbmV3VmVyc2lvbiA9IHNlbXZlckluYyh0aGlzLmFjdGl2ZS5yZWxlYXNlQ2FuZGlkYXRlIS52ZXJzaW9uLCAncHJlcmVsZWFzZScsICdyYycpO1xuXG4gIG92ZXJyaWRlIGFzeW5jIGdldERlc2NyaXB0aW9uKCkge1xuICAgIGNvbnN0IG5ld1ZlcnNpb24gPSB0aGlzLl9uZXdWZXJzaW9uO1xuICAgIHJldHVybiBgQ3V0IGEgZmlyc3QgcmVsZWFzZS1jYW5kaWRhdGUgZm9yIHRoZSBmZWF0dXJlLWZyZWV6ZSBicmFuY2ggKHYke25ld1ZlcnNpb259KS5gO1xuICB9XG5cbiAgb3ZlcnJpZGUgYXN5bmMgcGVyZm9ybSgpIHtcbiAgICBjb25zdCB7YnJhbmNoTmFtZX0gPSB0aGlzLmFjdGl2ZS5yZWxlYXNlQ2FuZGlkYXRlITtcbiAgICBjb25zdCBuZXdWZXJzaW9uID0gdGhpcy5fbmV3VmVyc2lvbjtcbiAgICBjb25zdCBjb21wYXJlVmVyc2lvbkZvclJlbGVhc2VOb3RlcyA9IHRoaXMuYWN0aXZlLnJlbGVhc2VDYW5kaWRhdGUhLnZlcnNpb247XG5cbiAgICBjb25zdCB7cHVsbFJlcXVlc3QsIHJlbGVhc2VOb3Rlc30gPSBhd2FpdCB0aGlzLmNoZWNrb3V0QnJhbmNoQW5kU3RhZ2VWZXJzaW9uKFxuICAgICAgbmV3VmVyc2lvbixcbiAgICAgIGNvbXBhcmVWZXJzaW9uRm9yUmVsZWFzZU5vdGVzLFxuICAgICAgYnJhbmNoTmFtZSxcbiAgICApO1xuXG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yUHVsbFJlcXVlc3RUb0JlTWVyZ2VkKHB1bGxSZXF1ZXN0KTtcbiAgICBhd2FpdCB0aGlzLmJ1aWxkQW5kUHVibGlzaChyZWxlYXNlTm90ZXMsIGJyYW5jaE5hbWUsICduZXh0Jyk7XG4gICAgYXdhaXQgdGhpcy5jaGVycnlQaWNrQ2hhbmdlbG9nSW50b05leHRCcmFuY2gocmVsZWFzZU5vdGVzLCBicmFuY2hOYW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBvdmVycmlkZSBhc3luYyBpc0FjdGl2ZShhY3RpdmU6IEFjdGl2ZVJlbGVhc2VUcmFpbnMpIHtcbiAgICAvLyBBIHJlbGVhc2UtY2FuZGlkYXRlIGNhbiBiZSBjdXQgZm9yIGFuIGFjdGl2ZSByZWxlYXNlLXRyYWluIGN1cnJlbnRseVxuICAgIC8vIGluIHRoZSBmZWF0dXJlLWZyZWV6ZSBwaGFzZS5cbiAgICByZXR1cm4gKFxuICAgICAgYWN0aXZlLnJlbGVhc2VDYW5kaWRhdGUgIT09IG51bGwgJiYgYWN0aXZlLnJlbGVhc2VDYW5kaWRhdGUudmVyc2lvbi5wcmVyZWxlYXNlWzBdID09PSAnbmV4dCdcbiAgICApO1xuICB9XG59XG4iXX0=