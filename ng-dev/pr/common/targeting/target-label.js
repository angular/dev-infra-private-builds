"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBranchesFromTargetLabel = exports.getTargetBranchesForPullRequest = exports.getMatchingTargetLabelForPullRequest = exports.InvalidTargetLabelError = exports.InvalidTargetBranchError = exports.TargetLabelName = void 0;
const labels_1 = require("./labels");
const validations_1 = require("../validation/validations");
const failures_1 = require("../validation/failures");
const versioning_1 = require("../../../release/versioning");
/**
 * Enum capturing available target label names in the Angular organization. A target
 * label is set on a pull request to specify where its changes should land.
 *
 * More details can be found here:
 * https://docs.google.com/document/d/197kVillDwx-RZtSVOBtPb4BBIAw0E9RT3q3v6DZkykU#heading=h.lkuypj38h15d
 */
var TargetLabelName;
(function (TargetLabelName) {
    TargetLabelName["MAJOR"] = "target: major";
    TargetLabelName["MINOR"] = "target: minor";
    TargetLabelName["PATCH"] = "target: patch";
    TargetLabelName["RELEASE_CANDIDATE"] = "target: rc";
    TargetLabelName["LONG_TERM_SUPPORT"] = "target: lts";
})(TargetLabelName = exports.TargetLabelName || (exports.TargetLabelName = {}));
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid branch is targeted.
 */
class InvalidTargetBranchError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetBranchError = InvalidTargetBranchError;
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid label has been applied to a pull request.
 */
class InvalidTargetLabelError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetLabelError = InvalidTargetLabelError;
/** Gets the target label from the specified pull request labels. */
async function getMatchingTargetLabelForPullRequest(config, labelsOnPullRequest, allTargetLabels) {
    if (config.noTargetLabeling) {
        throw Error('This repository does not use target labels');
    }
    const matches = [];
    for (const label of labelsOnPullRequest) {
        const match = allTargetLabels.find(({ name }) => label === name);
        if (match !== undefined) {
            matches.push(match);
        }
    }
    if (matches.length === 1) {
        return matches[0];
    }
    if (matches.length === 0) {
        throw new InvalidTargetLabelError('Unable to determine target for the PR as it has no target label.');
    }
    throw new InvalidTargetLabelError('Unable to determine target for the PR as it has multiple target labels.');
}
exports.getMatchingTargetLabelForPullRequest = getMatchingTargetLabelForPullRequest;
/** Get the branches the pull request should be merged into. */
async function getTargetBranchesForPullRequest(api, config, labelsOnPullRequest, githubTargetBranch, commits) {
    if (config.pullRequest.noTargetLabeling) {
        return [config.github.mainBranchName];
    }
    // If branches are determined for a given target label, capture errors that are
    // thrown as part of branch computation. This is expected because a merge configuration
    // can lazily compute branches for a target label and throw. e.g. if an invalid target
    // label is applied, we want to exit the script gracefully with an error message.
    try {
        const { mainBranchName, name, owner } = config.github;
        const releaseTrains = await (0, versioning_1.fetchActiveReleaseTrains)({
            name,
            nextBranchName: mainBranchName,
            owner,
            api,
        });
        const targetLabels = await (0, labels_1.getTargetLabelsForActiveReleaseTrains)(releaseTrains, api, config);
        const matchingLabel = await getMatchingTargetLabelForPullRequest(config.pullRequest, labelsOnPullRequest, targetLabels);
        const targetBranches = await getBranchesFromTargetLabel(matchingLabel, githubTargetBranch);
        (0, validations_1.assertChangesAllowForTargetLabel)(commits, matchingLabel, config.pullRequest, releaseTrains, labelsOnPullRequest);
        return targetBranches;
    }
    catch (error) {
        if (error instanceof InvalidTargetBranchError || error instanceof InvalidTargetLabelError) {
            throw new failures_1.PullRequestFailure(error.failureMessage);
        }
        throw error;
    }
}
exports.getTargetBranchesForPullRequest = getTargetBranchesForPullRequest;
/**
 * Gets the branches from the specified target label.
 *
 * @throws {InvalidTargetLabelError} Invalid label has been applied to pull request.
 * @throws {InvalidTargetBranchError} Invalid Github target branch has been selected.
 */
async function getBranchesFromTargetLabel(label, githubTargetBranch) {
    return typeof label.branches === 'function'
        ? await label.branches(githubTargetBranch)
        : await label.branches;
}
exports.getBranchesFromTargetLabel = getBranchesFromTargetLabel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFyZ2V0LWxhYmVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbmctZGV2L3ByL2NvbW1vbi90YXJnZXRpbmcvdGFyZ2V0LWxhYmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7OztBQUdILHFDQUErRDtBQUcvRCwyREFBMkU7QUFDM0UscURBQTBEO0FBRTFELDREQUFxRTtBQUVyRTs7Ozs7O0dBTUc7QUFDSCxJQUFZLGVBTVg7QUFORCxXQUFZLGVBQWU7SUFDekIsMENBQXVCLENBQUE7SUFDdkIsMENBQXVCLENBQUE7SUFDdkIsMENBQXVCLENBQUE7SUFDdkIsbURBQWdDLENBQUE7SUFDaEMsb0RBQWlDLENBQUE7QUFDbkMsQ0FBQyxFQU5XLGVBQWUsR0FBZix1QkFBZSxLQUFmLHVCQUFlLFFBTTFCO0FBb0JEOzs7R0FHRztBQUNILE1BQWEsd0JBQXdCO0lBQ25DLFlBQW1CLGNBQXNCO1FBQXRCLG1CQUFjLEdBQWQsY0FBYyxDQUFRO0lBQUcsQ0FBQztDQUM5QztBQUZELDREQUVDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBYSx1QkFBdUI7SUFDbEMsWUFBbUIsY0FBc0I7UUFBdEIsbUJBQWMsR0FBZCxjQUFjLENBQVE7SUFBRyxDQUFDO0NBQzlDO0FBRkQsMERBRUM7QUFFRCxvRUFBb0U7QUFDN0QsS0FBSyxVQUFVLG9DQUFvQyxDQUN4RCxNQUFtRCxFQUNuRCxtQkFBNkIsRUFDN0IsZUFBOEI7SUFFOUIsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLEVBQUU7UUFDM0IsTUFBTSxLQUFLLENBQUMsNENBQTRDLENBQUMsQ0FBQztLQUMzRDtJQUVELE1BQU0sT0FBTyxHQUFrQixFQUFFLENBQUM7SUFFbEMsS0FBSyxNQUFNLEtBQUssSUFBSSxtQkFBbUIsRUFBRTtRQUN2QyxNQUFNLEtBQUssR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBQyxJQUFJLEVBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxDQUFDO1FBQy9ELElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUN2QixPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3JCO0tBQ0Y7SUFDRCxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3hCLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ25CO0lBQ0QsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN4QixNQUFNLElBQUksdUJBQXVCLENBQy9CLGtFQUFrRSxDQUNuRSxDQUFDO0tBQ0g7SUFDRCxNQUFNLElBQUksdUJBQXVCLENBQy9CLHlFQUF5RSxDQUMxRSxDQUFDO0FBQ0osQ0FBQztBQTVCRCxvRkE0QkM7QUFFRCwrREFBK0Q7QUFDeEQsS0FBSyxVQUFVLCtCQUErQixDQUNuRCxHQUFpQixFQUNqQixNQUE4RCxFQUM5RCxtQkFBNkIsRUFDN0Isa0JBQTBCLEVBQzFCLE9BQWlCO0lBRWpCLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRTtRQUN2QyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUN2QztJQUVELCtFQUErRTtJQUMvRSx1RkFBdUY7SUFDdkYsc0ZBQXNGO0lBQ3RGLGlGQUFpRjtJQUNqRixJQUFJO1FBQ0YsTUFBTSxFQUFDLGNBQWMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNwRCxNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUEscUNBQXdCLEVBQUM7WUFDbkQsSUFBSTtZQUNKLGNBQWMsRUFBRSxjQUFjO1lBQzlCLEtBQUs7WUFDTCxHQUFHO1NBQ0osQ0FBQyxDQUFDO1FBQ0gsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFBLDhDQUFxQyxFQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDN0YsTUFBTSxhQUFhLEdBQUcsTUFBTSxvQ0FBb0MsQ0FDOUQsTUFBTSxDQUFDLFdBQVcsRUFDbEIsbUJBQW1CLEVBQ25CLFlBQVksQ0FDYixDQUFDO1FBQ0YsTUFBTSxjQUFjLEdBQUcsTUFBTSwwQkFBMEIsQ0FBQyxhQUFhLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztRQUUzRixJQUFBLDhDQUFnQyxFQUM5QixPQUFPLEVBQ1AsYUFBYSxFQUNiLE1BQU0sQ0FBQyxXQUFXLEVBQ2xCLGFBQWEsRUFDYixtQkFBbUIsQ0FDcEIsQ0FBQztRQUVGLE9BQU8sY0FBYyxDQUFDO0tBQ3ZCO0lBQUMsT0FBTyxLQUFLLEVBQUU7UUFDZCxJQUFJLEtBQUssWUFBWSx3QkFBd0IsSUFBSSxLQUFLLFlBQVksdUJBQXVCLEVBQUU7WUFDekYsTUFBTSxJQUFJLDZCQUFrQixDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUNwRDtRQUNELE1BQU0sS0FBSyxDQUFDO0tBQ2I7QUFDSCxDQUFDO0FBOUNELDBFQThDQztBQUVEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLDBCQUEwQixDQUM5QyxLQUFrQixFQUNsQixrQkFBMEI7SUFFMUIsT0FBTyxPQUFPLEtBQUssQ0FBQyxRQUFRLEtBQUssVUFBVTtRQUN6QyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDO1FBQzFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxRQUFRLENBQUM7QUFDM0IsQ0FBQztBQVBELGdFQU9DIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7UHVsbFJlcXVlc3RDb25maWd9IGZyb20gJy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQge2dldFRhcmdldExhYmVsc0ZvckFjdGl2ZVJlbGVhc2VUcmFpbnN9IGZyb20gJy4vbGFiZWxzJztcbmltcG9ydCB7R2l0aHViQ29uZmlnfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb25maWcnO1xuaW1wb3J0IHtDb21taXR9IGZyb20gJy4uLy4uLy4uL2NvbW1pdC1tZXNzYWdlL3BhcnNlJztcbmltcG9ydCB7YXNzZXJ0Q2hhbmdlc0FsbG93Rm9yVGFyZ2V0TGFiZWx9IGZyb20gJy4uL3ZhbGlkYXRpb24vdmFsaWRhdGlvbnMnO1xuaW1wb3J0IHtQdWxsUmVxdWVzdEZhaWx1cmV9IGZyb20gJy4uL3ZhbGlkYXRpb24vZmFpbHVyZXMnO1xuaW1wb3J0IHtHaXRodWJDbGllbnR9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2dpdC9naXRodWInO1xuaW1wb3J0IHtmZXRjaEFjdGl2ZVJlbGVhc2VUcmFpbnN9IGZyb20gJy4uLy4uLy4uL3JlbGVhc2UvdmVyc2lvbmluZyc7XG5cbi8qKlxuICogRW51bSBjYXB0dXJpbmcgYXZhaWxhYmxlIHRhcmdldCBsYWJlbCBuYW1lcyBpbiB0aGUgQW5ndWxhciBvcmdhbml6YXRpb24uIEEgdGFyZ2V0XG4gKiBsYWJlbCBpcyBzZXQgb24gYSBwdWxsIHJlcXVlc3QgdG8gc3BlY2lmeSB3aGVyZSBpdHMgY2hhbmdlcyBzaG91bGQgbGFuZC5cbiAqXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmU6XG4gKiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzE5N2tWaWxsRHd4LVJadFNWT0J0UGI0QkJJQXcwRTlSVDNxM3Y2RFpreWtVI2hlYWRpbmc9aC5sa3V5cGozOGgxNWRcbiAqL1xuZXhwb3J0IGVudW0gVGFyZ2V0TGFiZWxOYW1lIHtcbiAgTUFKT1IgPSAndGFyZ2V0OiBtYWpvcicsXG4gIE1JTk9SID0gJ3RhcmdldDogbWlub3InLFxuICBQQVRDSCA9ICd0YXJnZXQ6IHBhdGNoJyxcbiAgUkVMRUFTRV9DQU5ESURBVEUgPSAndGFyZ2V0OiByYycsXG4gIExPTkdfVEVSTV9TVVBQT1JUID0gJ3RhcmdldDogbHRzJyxcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgYSBsYWJlbCB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIGEgcHVsbCByZXF1ZXN0IHRvIG1hcmsgaW50b1xuICogd2hpY2ggYnJhbmNoZXMgaXQgc2hvdWxkIGJlIG1lcmdlZCBpbnRvLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhcmdldExhYmVsIHtcbiAgLyoqIE5hbWUgb2YgdGhlIHRhcmdldCBsYWJlbC4gTmVlZHMgdG8gbWF0Y2ggd2l0aCB0aGUgbmFtZSBvZiB0aGUgbGFiZWwgb24gR2l0aHViLiAqL1xuICBuYW1lOiBUYXJnZXRMYWJlbE5hbWU7XG4gIC8qKlxuICAgKiBMaXN0IG9mIGJyYW5jaGVzIGEgcHVsbCByZXF1ZXN0IHdpdGggdGhpcyB0YXJnZXQgbGFiZWwgc2hvdWxkIGJlIG1lcmdlZCBpbnRvLlxuICAgKiBDYW4gYWxzbyBiZSB3cmFwcGVkIGluIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSB0YXJnZXQgYnJhbmNoIHNwZWNpZmllZCBpbiB0aGVcbiAgICogR2l0aHViIFdlYiBVSS4gVGhpcyBpcyB1c2VmdWwgZm9yIHN1cHBvcnRpbmcgbGFiZWxzIGxpa2UgYHRhcmdldDogZGV2ZWxvcG1lbnQtYnJhbmNoYC5cbiAgICpcbiAgICogQHRocm93cyB7SW52YWxpZFRhcmdldExhYmVsRXJyb3J9IEludmFsaWQgbGFiZWwgaGFzIGJlZW4gYXBwbGllZCB0byBwdWxsIHJlcXVlc3QuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRUYXJnZXRCcmFuY2hFcnJvcn0gSW52YWxpZCBHaXRodWIgdGFyZ2V0IGJyYW5jaCBoYXMgYmVlbiBzZWxlY3RlZC5cbiAgICovXG4gIGJyYW5jaGVzOiAoZ2l0aHViVGFyZ2V0QnJhbmNoOiBzdHJpbmcpID0+IHN0cmluZ1tdIHwgUHJvbWlzZTxzdHJpbmdbXT47XG59XG5cbi8qKlxuICogVW5pcXVlIGVycm9yIHRoYXQgY2FuIGJlIHRocm93biBpbiB0aGUgbWVyZ2UgY29uZmlndXJhdGlvbiBpZiBhblxuICogaW52YWxpZCBicmFuY2ggaXMgdGFyZ2V0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVGFyZ2V0QnJhbmNoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgZmFpbHVyZU1lc3NhZ2U6IHN0cmluZykge31cbn1cblxuLyoqXG4gKiBVbmlxdWUgZXJyb3IgdGhhdCBjYW4gYmUgdGhyb3duIGluIHRoZSBtZXJnZSBjb25maWd1cmF0aW9uIGlmIGFuXG4gKiBpbnZhbGlkIGxhYmVsIGhhcyBiZWVuIGFwcGxpZWQgdG8gYSBwdWxsIHJlcXVlc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWlsdXJlTWVzc2FnZTogc3RyaW5nKSB7fVxufVxuXG4vKiogR2V0cyB0aGUgdGFyZ2V0IGxhYmVsIGZyb20gdGhlIHNwZWNpZmllZCBwdWxsIHJlcXVlc3QgbGFiZWxzLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1hdGNoaW5nVGFyZ2V0TGFiZWxGb3JQdWxsUmVxdWVzdChcbiAgY29uZmlnOiBQaWNrPFB1bGxSZXF1ZXN0Q29uZmlnLCAnbm9UYXJnZXRMYWJlbGluZyc+LFxuICBsYWJlbHNPblB1bGxSZXF1ZXN0OiBzdHJpbmdbXSxcbiAgYWxsVGFyZ2V0TGFiZWxzOiBUYXJnZXRMYWJlbFtdLFxuKTogUHJvbWlzZTxUYXJnZXRMYWJlbD4ge1xuICBpZiAoY29uZmlnLm5vVGFyZ2V0TGFiZWxpbmcpIHtcbiAgICB0aHJvdyBFcnJvcignVGhpcyByZXBvc2l0b3J5IGRvZXMgbm90IHVzZSB0YXJnZXQgbGFiZWxzJyk7XG4gIH1cblxuICBjb25zdCBtYXRjaGVzOiBUYXJnZXRMYWJlbFtdID0gW107XG5cbiAgZm9yIChjb25zdCBsYWJlbCBvZiBsYWJlbHNPblB1bGxSZXF1ZXN0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBhbGxUYXJnZXRMYWJlbHMuZmluZCgoe25hbWV9KSA9PiBsYWJlbCA9PT0gbmFtZSk7XG4gICAgaWYgKG1hdGNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICB9XG4gIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvcihcbiAgICAgICdVbmFibGUgdG8gZGV0ZXJtaW5lIHRhcmdldCBmb3IgdGhlIFBSIGFzIGl0IGhhcyBubyB0YXJnZXQgbGFiZWwuJyxcbiAgICApO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvcihcbiAgICAnVW5hYmxlIHRvIGRldGVybWluZSB0YXJnZXQgZm9yIHRoZSBQUiBhcyBpdCBoYXMgbXVsdGlwbGUgdGFyZ2V0IGxhYmVscy4nLFxuICApO1xufVxuXG4vKiogR2V0IHRoZSBicmFuY2hlcyB0aGUgcHVsbCByZXF1ZXN0IHNob3VsZCBiZSBtZXJnZWQgaW50by4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUYXJnZXRCcmFuY2hlc0ZvclB1bGxSZXF1ZXN0KFxuICBhcGk6IEdpdGh1YkNsaWVudCxcbiAgY29uZmlnOiB7cHVsbFJlcXVlc3Q6IFB1bGxSZXF1ZXN0Q29uZmlnOyBnaXRodWI6IEdpdGh1YkNvbmZpZ30sXG4gIGxhYmVsc09uUHVsbFJlcXVlc3Q6IHN0cmluZ1tdLFxuICBnaXRodWJUYXJnZXRCcmFuY2g6IHN0cmluZyxcbiAgY29tbWl0czogQ29tbWl0W10sXG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGlmIChjb25maWcucHVsbFJlcXVlc3Qubm9UYXJnZXRMYWJlbGluZykge1xuICAgIHJldHVybiBbY29uZmlnLmdpdGh1Yi5tYWluQnJhbmNoTmFtZV07XG4gIH1cblxuICAvLyBJZiBicmFuY2hlcyBhcmUgZGV0ZXJtaW5lZCBmb3IgYSBnaXZlbiB0YXJnZXQgbGFiZWwsIGNhcHR1cmUgZXJyb3JzIHRoYXQgYXJlXG4gIC8vIHRocm93biBhcyBwYXJ0IG9mIGJyYW5jaCBjb21wdXRhdGlvbi4gVGhpcyBpcyBleHBlY3RlZCBiZWNhdXNlIGEgbWVyZ2UgY29uZmlndXJhdGlvblxuICAvLyBjYW4gbGF6aWx5IGNvbXB1dGUgYnJhbmNoZXMgZm9yIGEgdGFyZ2V0IGxhYmVsIGFuZCB0aHJvdy4gZS5nLiBpZiBhbiBpbnZhbGlkIHRhcmdldFxuICAvLyBsYWJlbCBpcyBhcHBsaWVkLCB3ZSB3YW50IHRvIGV4aXQgdGhlIHNjcmlwdCBncmFjZWZ1bGx5IHdpdGggYW4gZXJyb3IgbWVzc2FnZS5cbiAgdHJ5IHtcbiAgICBjb25zdCB7bWFpbkJyYW5jaE5hbWUsIG5hbWUsIG93bmVyfSA9IGNvbmZpZy5naXRodWI7XG4gICAgY29uc3QgcmVsZWFzZVRyYWlucyA9IGF3YWl0IGZldGNoQWN0aXZlUmVsZWFzZVRyYWlucyh7XG4gICAgICBuYW1lLFxuICAgICAgbmV4dEJyYW5jaE5hbWU6IG1haW5CcmFuY2hOYW1lLFxuICAgICAgb3duZXIsXG4gICAgICBhcGksXG4gICAgfSk7XG4gICAgY29uc3QgdGFyZ2V0TGFiZWxzID0gYXdhaXQgZ2V0VGFyZ2V0TGFiZWxzRm9yQWN0aXZlUmVsZWFzZVRyYWlucyhyZWxlYXNlVHJhaW5zLCBhcGksIGNvbmZpZyk7XG4gICAgY29uc3QgbWF0Y2hpbmdMYWJlbCA9IGF3YWl0IGdldE1hdGNoaW5nVGFyZ2V0TGFiZWxGb3JQdWxsUmVxdWVzdChcbiAgICAgIGNvbmZpZy5wdWxsUmVxdWVzdCxcbiAgICAgIGxhYmVsc09uUHVsbFJlcXVlc3QsXG4gICAgICB0YXJnZXRMYWJlbHMsXG4gICAgKTtcbiAgICBjb25zdCB0YXJnZXRCcmFuY2hlcyA9IGF3YWl0IGdldEJyYW5jaGVzRnJvbVRhcmdldExhYmVsKG1hdGNoaW5nTGFiZWwsIGdpdGh1YlRhcmdldEJyYW5jaCk7XG5cbiAgICBhc3NlcnRDaGFuZ2VzQWxsb3dGb3JUYXJnZXRMYWJlbChcbiAgICAgIGNvbW1pdHMsXG4gICAgICBtYXRjaGluZ0xhYmVsLFxuICAgICAgY29uZmlnLnB1bGxSZXF1ZXN0LFxuICAgICAgcmVsZWFzZVRyYWlucyxcbiAgICAgIGxhYmVsc09uUHVsbFJlcXVlc3QsXG4gICAgKTtcblxuICAgIHJldHVybiB0YXJnZXRCcmFuY2hlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJbnZhbGlkVGFyZ2V0QnJhbmNoRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFB1bGxSZXF1ZXN0RmFpbHVyZShlcnJvci5mYWlsdXJlTWVzc2FnZSk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYnJhbmNoZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHRhcmdldCBsYWJlbC5cbiAqXG4gKiBAdGhyb3dzIHtJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvcn0gSW52YWxpZCBsYWJlbCBoYXMgYmVlbiBhcHBsaWVkIHRvIHB1bGwgcmVxdWVzdC5cbiAqIEB0aHJvd3Mge0ludmFsaWRUYXJnZXRCcmFuY2hFcnJvcn0gSW52YWxpZCBHaXRodWIgdGFyZ2V0IGJyYW5jaCBoYXMgYmVlbiBzZWxlY3RlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyYW5jaGVzRnJvbVRhcmdldExhYmVsKFxuICBsYWJlbDogVGFyZ2V0TGFiZWwsXG4gIGdpdGh1YlRhcmdldEJyYW5jaDogc3RyaW5nLFxuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICByZXR1cm4gdHlwZW9mIGxhYmVsLmJyYW5jaGVzID09PSAnZnVuY3Rpb24nXG4gICAgPyBhd2FpdCBsYWJlbC5icmFuY2hlcyhnaXRodWJUYXJnZXRCcmFuY2gpXG4gICAgOiBhd2FpdCBsYWJlbC5icmFuY2hlcztcbn1cbiJdfQ==