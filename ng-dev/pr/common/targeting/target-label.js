"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBranchesFromTargetLabel = exports.getTargetBranchesForPullRequest = exports.getMatchingTargetLabelForPullRequest = exports.InvalidTargetLabelError = exports.InvalidTargetBranchError = exports.TargetLabelName = void 0;
const labels_1 = require("./labels");
const validations_1 = require("../validation/validations");
const failures_1 = require("../validation/failures");
/**
 * Enum capturing available target label names in the Angular organization. A target
 * label is set on a pull request to specify where its changes should land.
 *
 * More details can be found here:
 * https://docs.google.com/document/d/197kVillDwx-RZtSVOBtPb4BBIAw0E9RT3q3v6DZkykU#heading=h.lkuypj38h15d
 */
var TargetLabelName;
(function (TargetLabelName) {
    TargetLabelName["MAJOR"] = "target: major";
    TargetLabelName["MINOR"] = "target: minor";
    TargetLabelName["PATCH"] = "target: patch";
    TargetLabelName["RELEASE_CANDIDATE"] = "target: rc";
    TargetLabelName["LONG_TERM_SUPPORT"] = "target: lts";
})(TargetLabelName = exports.TargetLabelName || (exports.TargetLabelName = {}));
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid branch is targeted.
 */
class InvalidTargetBranchError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetBranchError = InvalidTargetBranchError;
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid label has been applied to a pull request.
 */
class InvalidTargetLabelError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetLabelError = InvalidTargetLabelError;
/** Gets the target label from the specified pull request labels. */
async function getMatchingTargetLabelForPullRequest(config, labelsOnPullRequest, allTargetLabels) {
    if (config.noTargetLabeling) {
        throw Error('This repository does not use target labels');
    }
    const matches = [];
    for (const label of labelsOnPullRequest) {
        const match = allTargetLabels.find(({ name }) => label === name);
        if (match !== undefined) {
            matches.push(match);
        }
    }
    if (matches.length === 1) {
        return matches[0];
    }
    if (matches.length === 0) {
        throw new InvalidTargetLabelError('Unable to determine target for the PR as it has no target label.');
    }
    throw new InvalidTargetLabelError('Unable to determine target for the PR as it has multiple target labels.');
}
exports.getMatchingTargetLabelForPullRequest = getMatchingTargetLabelForPullRequest;
/** Get the branches the pull request should be merged into. */
async function getTargetBranchesForPullRequest(api, config, labelsOnPullRequest, githubTargetBranch, commits) {
    if (config.merge.noTargetLabeling) {
        return [config.github.mainBranchName];
    }
    // If branches are determined for a given target label, capture errors that are
    // thrown as part of branch computation. This is expected because a merge configuration
    // can lazily compute branches for a target label and throw. e.g. if an invalid target
    // label is applied, we want to exit the script gracefully with an error message.
    try {
        const targetLabels = await (0, labels_1.getTargetLabelsForActiveReleaseTrains)(api, config);
        const matchingLabel = await getMatchingTargetLabelForPullRequest(config.merge, labelsOnPullRequest, targetLabels);
        const targetBranches = await getBranchesFromTargetLabel(matchingLabel, githubTargetBranch);
        (0, validations_1.assertChangesAllowForTargetLabel)(commits, matchingLabel, config.merge);
        return targetBranches;
    }
    catch (error) {
        if (error instanceof InvalidTargetBranchError || error instanceof InvalidTargetLabelError) {
            throw new failures_1.PullRequestFailure(error.failureMessage);
        }
        throw error;
    }
}
exports.getTargetBranchesForPullRequest = getTargetBranchesForPullRequest;
/**
 * Gets the branches from the specified target label.
 *
 * @throws {InvalidTargetLabelError} Invalid label has been applied to pull request.
 * @throws {InvalidTargetBranchError} Invalid Github target branch has been selected.
 */
async function getBranchesFromTargetLabel(label, githubTargetBranch) {
    return typeof label.branches === 'function'
        ? await label.branches(githubTargetBranch)
        : await label.branches;
}
exports.getBranchesFromTargetLabel = getBranchesFromTargetLabel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFyZ2V0LWxhYmVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbmctZGV2L3ByL2NvbW1vbi90YXJnZXRpbmcvdGFyZ2V0LWxhYmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7OztBQUdILHFDQUErRDtBQUcvRCwyREFBMkU7QUFDM0UscURBQTBEO0FBRzFEOzs7Ozs7R0FNRztBQUNILElBQVksZUFNWDtBQU5ELFdBQVksZUFBZTtJQUN6QiwwQ0FBdUIsQ0FBQTtJQUN2QiwwQ0FBdUIsQ0FBQTtJQUN2QiwwQ0FBdUIsQ0FBQTtJQUN2QixtREFBZ0MsQ0FBQTtJQUNoQyxvREFBaUMsQ0FBQTtBQUNuQyxDQUFDLEVBTlcsZUFBZSxHQUFmLHVCQUFlLEtBQWYsdUJBQWUsUUFNMUI7QUFvQkQ7OztHQUdHO0FBQ0gsTUFBYSx3QkFBd0I7SUFDbkMsWUFBbUIsY0FBc0I7UUFBdEIsbUJBQWMsR0FBZCxjQUFjLENBQVE7SUFBRyxDQUFDO0NBQzlDO0FBRkQsNERBRUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFhLHVCQUF1QjtJQUNsQyxZQUFtQixjQUFzQjtRQUF0QixtQkFBYyxHQUFkLGNBQWMsQ0FBUTtJQUFHLENBQUM7Q0FDOUM7QUFGRCwwREFFQztBQUVELG9FQUFvRTtBQUM3RCxLQUFLLFVBQVUsb0NBQW9DLENBQ3hELE1BQTZDLEVBQzdDLG1CQUE2QixFQUM3QixlQUE4QjtJQUU5QixJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtRQUMzQixNQUFNLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0tBQzNEO0lBRUQsTUFBTSxPQUFPLEdBQWtCLEVBQUUsQ0FBQztJQUVsQyxLQUFLLE1BQU0sS0FBSyxJQUFJLG1CQUFtQixFQUFFO1FBQ3ZDLE1BQU0sS0FBSyxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFDLElBQUksRUFBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLENBQUM7UUFDL0QsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDckI7S0FDRjtJQUNELElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDeEIsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbkI7SUFDRCxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3hCLE1BQU0sSUFBSSx1QkFBdUIsQ0FDL0Isa0VBQWtFLENBQ25FLENBQUM7S0FDSDtJQUNELE1BQU0sSUFBSSx1QkFBdUIsQ0FDL0IseUVBQXlFLENBQzFFLENBQUM7QUFDSixDQUFDO0FBNUJELG9GQTRCQztBQUVELCtEQUErRDtBQUN4RCxLQUFLLFVBQVUsK0JBQStCLENBQ25ELEdBQWlCLEVBQ2pCLE1BQWtELEVBQ2xELG1CQUE2QixFQUM3QixrQkFBMEIsRUFDMUIsT0FBaUI7SUFFakIsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQixFQUFFO1FBQ2pDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQ3ZDO0lBRUQsK0VBQStFO0lBQy9FLHVGQUF1RjtJQUN2RixzRkFBc0Y7SUFDdEYsaUZBQWlGO0lBQ2pGLElBQUk7UUFDRixNQUFNLFlBQVksR0FBRyxNQUFNLElBQUEsOENBQXFDLEVBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzlFLE1BQU0sYUFBYSxHQUFHLE1BQU0sb0NBQW9DLENBQzlELE1BQU0sQ0FBQyxLQUFLLEVBQ1osbUJBQW1CLEVBQ25CLFlBQVksQ0FDYixDQUFDO1FBQ0YsTUFBTSxjQUFjLEdBQUcsTUFBTSwwQkFBMEIsQ0FBQyxhQUFhLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztRQUUzRixJQUFBLDhDQUFnQyxFQUFDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXZFLE9BQU8sY0FBYyxDQUFDO0tBQ3ZCO0lBQUMsT0FBTyxLQUFLLEVBQUU7UUFDZCxJQUFJLEtBQUssWUFBWSx3QkFBd0IsSUFBSSxLQUFLLFlBQVksdUJBQXVCLEVBQUU7WUFDekYsTUFBTSxJQUFJLDZCQUFrQixDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUNwRDtRQUNELE1BQU0sS0FBSyxDQUFDO0tBQ2I7QUFDSCxDQUFDO0FBakNELDBFQWlDQztBQUVEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLDBCQUEwQixDQUM5QyxLQUFrQixFQUNsQixrQkFBMEI7SUFFMUIsT0FBTyxPQUFPLEtBQUssQ0FBQyxRQUFRLEtBQUssVUFBVTtRQUN6QyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDO1FBQzFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxRQUFRLENBQUM7QUFDM0IsQ0FBQztBQVBELGdFQU9DIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7TWVyZ2VDb25maWd9IGZyb20gJy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQge2dldFRhcmdldExhYmVsc0ZvckFjdGl2ZVJlbGVhc2VUcmFpbnN9IGZyb20gJy4vbGFiZWxzJztcbmltcG9ydCB7R2l0aHViQ29uZmlnfSBmcm9tICcuLi8uLi8uLi91dGlscy9jb25maWcnO1xuaW1wb3J0IHtDb21taXR9IGZyb20gJy4uLy4uLy4uL2NvbW1pdC1tZXNzYWdlL3BhcnNlJztcbmltcG9ydCB7YXNzZXJ0Q2hhbmdlc0FsbG93Rm9yVGFyZ2V0TGFiZWx9IGZyb20gJy4uL3ZhbGlkYXRpb24vdmFsaWRhdGlvbnMnO1xuaW1wb3J0IHtQdWxsUmVxdWVzdEZhaWx1cmV9IGZyb20gJy4uL3ZhbGlkYXRpb24vZmFpbHVyZXMnO1xuaW1wb3J0IHtHaXRodWJDbGllbnR9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2dpdC9naXRodWInO1xuXG4vKipcbiAqIEVudW0gY2FwdHVyaW5nIGF2YWlsYWJsZSB0YXJnZXQgbGFiZWwgbmFtZXMgaW4gdGhlIEFuZ3VsYXIgb3JnYW5pemF0aW9uLiBBIHRhcmdldFxuICogbGFiZWwgaXMgc2V0IG9uIGEgcHVsbCByZXF1ZXN0IHRvIHNwZWNpZnkgd2hlcmUgaXRzIGNoYW5nZXMgc2hvdWxkIGxhbmQuXG4gKlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlOlxuICogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xOTdrVmlsbER3eC1SWnRTVk9CdFBiNEJCSUF3MEU5UlQzcTN2NkRaa3lrVSNoZWFkaW5nPWgubGt1eXBqMzhoMTVkXG4gKi9cbmV4cG9ydCBlbnVtIFRhcmdldExhYmVsTmFtZSB7XG4gIE1BSk9SID0gJ3RhcmdldDogbWFqb3InLFxuICBNSU5PUiA9ICd0YXJnZXQ6IG1pbm9yJyxcbiAgUEFUQ0ggPSAndGFyZ2V0OiBwYXRjaCcsXG4gIFJFTEVBU0VfQ0FORElEQVRFID0gJ3RhcmdldDogcmMnLFxuICBMT05HX1RFUk1fU1VQUE9SVCA9ICd0YXJnZXQ6IGx0cycsXG59XG5cbi8qKlxuICogRGVzY3JpYmVzIGEgbGFiZWwgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhIHB1bGwgcmVxdWVzdCB0byBtYXJrIGludG9cbiAqIHdoaWNoIGJyYW5jaGVzIGl0IHNob3VsZCBiZSBtZXJnZWQgaW50by5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUYXJnZXRMYWJlbCB7XG4gIC8qKiBOYW1lIG9mIHRoZSB0YXJnZXQgbGFiZWwuIE5lZWRzIHRvIG1hdGNoIHdpdGggdGhlIG5hbWUgb2YgdGhlIGxhYmVsIG9uIEdpdGh1Yi4gKi9cbiAgbmFtZTogVGFyZ2V0TGFiZWxOYW1lO1xuICAvKipcbiAgICogTGlzdCBvZiBicmFuY2hlcyBhIHB1bGwgcmVxdWVzdCB3aXRoIHRoaXMgdGFyZ2V0IGxhYmVsIHNob3VsZCBiZSBtZXJnZWQgaW50by5cbiAgICogQ2FuIGFsc28gYmUgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgdGFyZ2V0IGJyYW5jaCBzcGVjaWZpZWQgaW4gdGhlXG4gICAqIEdpdGh1YiBXZWIgVUkuIFRoaXMgaXMgdXNlZnVsIGZvciBzdXBwb3J0aW5nIGxhYmVscyBsaWtlIGB0YXJnZXQ6IGRldmVsb3BtZW50LWJyYW5jaGAuXG4gICAqXG4gICAqIEB0aHJvd3Mge0ludmFsaWRUYXJnZXRMYWJlbEVycm9yfSBJbnZhbGlkIGxhYmVsIGhhcyBiZWVuIGFwcGxpZWQgdG8gcHVsbCByZXF1ZXN0LlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkVGFyZ2V0QnJhbmNoRXJyb3J9IEludmFsaWQgR2l0aHViIHRhcmdldCBicmFuY2ggaGFzIGJlZW4gc2VsZWN0ZWQuXG4gICAqL1xuICBicmFuY2hlczogKGdpdGh1YlRhcmdldEJyYW5jaDogc3RyaW5nKSA9PiBzdHJpbmdbXSB8IFByb21pc2U8c3RyaW5nW10+O1xufVxuXG4vKipcbiAqIFVuaXF1ZSBlcnJvciB0aGF0IGNhbiBiZSB0aHJvd24gaW4gdGhlIG1lcmdlIGNvbmZpZ3VyYXRpb24gaWYgYW5cbiAqIGludmFsaWQgYnJhbmNoIGlzIHRhcmdldGVkLlxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFRhcmdldEJyYW5jaEVycm9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIGZhaWx1cmVNZXNzYWdlOiBzdHJpbmcpIHt9XG59XG5cbi8qKlxuICogVW5pcXVlIGVycm9yIHRoYXQgY2FuIGJlIHRocm93biBpbiB0aGUgbWVyZ2UgY29uZmlndXJhdGlvbiBpZiBhblxuICogaW52YWxpZCBsYWJlbCBoYXMgYmVlbiBhcHBsaWVkIHRvIGEgcHVsbCByZXF1ZXN0LlxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFRhcmdldExhYmVsRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgZmFpbHVyZU1lc3NhZ2U6IHN0cmluZykge31cbn1cblxuLyoqIEdldHMgdGhlIHRhcmdldCBsYWJlbCBmcm9tIHRoZSBzcGVjaWZpZWQgcHVsbCByZXF1ZXN0IGxhYmVscy4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNYXRjaGluZ1RhcmdldExhYmVsRm9yUHVsbFJlcXVlc3QoXG4gIGNvbmZpZzogUGljazxNZXJnZUNvbmZpZywgJ25vVGFyZ2V0TGFiZWxpbmcnPixcbiAgbGFiZWxzT25QdWxsUmVxdWVzdDogc3RyaW5nW10sXG4gIGFsbFRhcmdldExhYmVsczogVGFyZ2V0TGFiZWxbXSxcbik6IFByb21pc2U8VGFyZ2V0TGFiZWw+IHtcbiAgaWYgKGNvbmZpZy5ub1RhcmdldExhYmVsaW5nKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1RoaXMgcmVwb3NpdG9yeSBkb2VzIG5vdCB1c2UgdGFyZ2V0IGxhYmVscycpO1xuICB9XG5cbiAgY29uc3QgbWF0Y2hlczogVGFyZ2V0TGFiZWxbXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzT25QdWxsUmVxdWVzdCkge1xuICAgIGNvbnN0IG1hdGNoID0gYWxsVGFyZ2V0TGFiZWxzLmZpbmQoKHtuYW1lfSkgPT4gbGFiZWwgPT09IG5hbWUpO1xuICAgIGlmIChtYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1swXTtcbiAgfVxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRhcmdldExhYmVsRXJyb3IoXG4gICAgICAnVW5hYmxlIHRvIGRldGVybWluZSB0YXJnZXQgZm9yIHRoZSBQUiBhcyBpdCBoYXMgbm8gdGFyZ2V0IGxhYmVsLicsXG4gICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZFRhcmdldExhYmVsRXJyb3IoXG4gICAgJ1VuYWJsZSB0byBkZXRlcm1pbmUgdGFyZ2V0IGZvciB0aGUgUFIgYXMgaXQgaGFzIG11bHRpcGxlIHRhcmdldCBsYWJlbHMuJyxcbiAgKTtcbn1cblxuLyoqIEdldCB0aGUgYnJhbmNoZXMgdGhlIHB1bGwgcmVxdWVzdCBzaG91bGQgYmUgbWVyZ2VkIGludG8uICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VGFyZ2V0QnJhbmNoZXNGb3JQdWxsUmVxdWVzdChcbiAgYXBpOiBHaXRodWJDbGllbnQsXG4gIGNvbmZpZzoge21lcmdlOiBNZXJnZUNvbmZpZzsgZ2l0aHViOiBHaXRodWJDb25maWd9LFxuICBsYWJlbHNPblB1bGxSZXF1ZXN0OiBzdHJpbmdbXSxcbiAgZ2l0aHViVGFyZ2V0QnJhbmNoOiBzdHJpbmcsXG4gIGNvbW1pdHM6IENvbW1pdFtdLFxuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBpZiAoY29uZmlnLm1lcmdlLm5vVGFyZ2V0TGFiZWxpbmcpIHtcbiAgICByZXR1cm4gW2NvbmZpZy5naXRodWIubWFpbkJyYW5jaE5hbWVdO1xuICB9XG5cbiAgLy8gSWYgYnJhbmNoZXMgYXJlIGRldGVybWluZWQgZm9yIGEgZ2l2ZW4gdGFyZ2V0IGxhYmVsLCBjYXB0dXJlIGVycm9ycyB0aGF0IGFyZVxuICAvLyB0aHJvd24gYXMgcGFydCBvZiBicmFuY2ggY29tcHV0YXRpb24uIFRoaXMgaXMgZXhwZWN0ZWQgYmVjYXVzZSBhIG1lcmdlIGNvbmZpZ3VyYXRpb25cbiAgLy8gY2FuIGxhemlseSBjb21wdXRlIGJyYW5jaGVzIGZvciBhIHRhcmdldCBsYWJlbCBhbmQgdGhyb3cuIGUuZy4gaWYgYW4gaW52YWxpZCB0YXJnZXRcbiAgLy8gbGFiZWwgaXMgYXBwbGllZCwgd2Ugd2FudCB0byBleGl0IHRoZSBzY3JpcHQgZ3JhY2VmdWxseSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UuXG4gIHRyeSB7XG4gICAgY29uc3QgdGFyZ2V0TGFiZWxzID0gYXdhaXQgZ2V0VGFyZ2V0TGFiZWxzRm9yQWN0aXZlUmVsZWFzZVRyYWlucyhhcGksIGNvbmZpZyk7XG4gICAgY29uc3QgbWF0Y2hpbmdMYWJlbCA9IGF3YWl0IGdldE1hdGNoaW5nVGFyZ2V0TGFiZWxGb3JQdWxsUmVxdWVzdChcbiAgICAgIGNvbmZpZy5tZXJnZSxcbiAgICAgIGxhYmVsc09uUHVsbFJlcXVlc3QsXG4gICAgICB0YXJnZXRMYWJlbHMsXG4gICAgKTtcbiAgICBjb25zdCB0YXJnZXRCcmFuY2hlcyA9IGF3YWl0IGdldEJyYW5jaGVzRnJvbVRhcmdldExhYmVsKG1hdGNoaW5nTGFiZWwsIGdpdGh1YlRhcmdldEJyYW5jaCk7XG5cbiAgICBhc3NlcnRDaGFuZ2VzQWxsb3dGb3JUYXJnZXRMYWJlbChjb21taXRzLCBtYXRjaGluZ0xhYmVsLCBjb25maWcubWVyZ2UpO1xuXG4gICAgcmV0dXJuIHRhcmdldEJyYW5jaGVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEludmFsaWRUYXJnZXRCcmFuY2hFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEludmFsaWRUYXJnZXRMYWJlbEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUHVsbFJlcXVlc3RGYWlsdXJlKGVycm9yLmZhaWx1cmVNZXNzYWdlKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBicmFuY2hlcyBmcm9tIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGxhYmVsLlxuICpcbiAqIEB0aHJvd3Mge0ludmFsaWRUYXJnZXRMYWJlbEVycm9yfSBJbnZhbGlkIGxhYmVsIGhhcyBiZWVuIGFwcGxpZWQgdG8gcHVsbCByZXF1ZXN0LlxuICogQHRocm93cyB7SW52YWxpZFRhcmdldEJyYW5jaEVycm9yfSBJbnZhbGlkIEdpdGh1YiB0YXJnZXQgYnJhbmNoIGhhcyBiZWVuIHNlbGVjdGVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QnJhbmNoZXNGcm9tVGFyZ2V0TGFiZWwoXG4gIGxhYmVsOiBUYXJnZXRMYWJlbCxcbiAgZ2l0aHViVGFyZ2V0QnJhbmNoOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIHJldHVybiB0eXBlb2YgbGFiZWwuYnJhbmNoZXMgPT09ICdmdW5jdGlvbidcbiAgICA/IGF3YWl0IGxhYmVsLmJyYW5jaGVzKGdpdGh1YlRhcmdldEJyYW5jaClcbiAgICA6IGF3YWl0IGxhYmVsLmJyYW5jaGVzO1xufVxuIl19