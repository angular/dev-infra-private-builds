"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBranchesFromTargetLabel = exports.getTargetBranchesForPullRequest = exports.getMatchingTargetLabelForPullRequest = exports.InvalidTargetLabelError = exports.InvalidTargetBranchError = exports.TargetLabelName = void 0;
const labels_1 = require("./labels");
const validations_1 = require("../validation/validations");
const failures_1 = require("../validation/failures");
/**
 * Enum capturing available target label names in the Angular organization. A target
 * label is set on a pull request to specify where its changes should land.
 *
 * More details can be found here:
 * https://docs.google.com/document/d/197kVillDwx-RZtSVOBtPb4BBIAw0E9RT3q3v6DZkykU#heading=h.lkuypj38h15d
 */
var TargetLabelName;
(function (TargetLabelName) {
    TargetLabelName["MAJOR"] = "target: major";
    TargetLabelName["MINOR"] = "target: minor";
    TargetLabelName["PATCH"] = "target: patch";
    TargetLabelName["RELEASE_CANDIDATE"] = "target: rc";
    TargetLabelName["LONG_TERM_SUPPORT"] = "target: lts";
})(TargetLabelName = exports.TargetLabelName || (exports.TargetLabelName = {}));
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid branch is targeted.
 */
class InvalidTargetBranchError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetBranchError = InvalidTargetBranchError;
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid label has been applied to a pull request.
 */
class InvalidTargetLabelError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetLabelError = InvalidTargetLabelError;
/** Gets the target label from the specified pull request labels. */
async function getMatchingTargetLabelForPullRequest(config, labelsOnPullRequest, allTargetLabels) {
    if (config.noTargetLabeling) {
        throw Error('This repository does not use target labels');
    }
    const matches = [];
    for (const label of labelsOnPullRequest) {
        const match = allTargetLabels.find(({ name }) => label === name);
        if (match !== undefined) {
            matches.push(match);
        }
    }
    if (matches.length === 1) {
        return matches[0];
    }
    if (matches.length === 0) {
        throw new InvalidTargetLabelError('Unable to determine target for the PR as it has no target label.');
    }
    throw new InvalidTargetLabelError('Unable to determine target for the PR as it has multiple target labels.');
}
exports.getMatchingTargetLabelForPullRequest = getMatchingTargetLabelForPullRequest;
/** Get the branches the pull request should be merged into. */
async function getTargetBranchesForPullRequest(api, config, labelsOnPullRequest, githubTargetBranch, commits) {
    if (config.pullRequest.noTargetLabeling) {
        return [config.github.mainBranchName];
    }
    // If branches are determined for a given target label, capture errors that are
    // thrown as part of branch computation. This is expected because a merge configuration
    // can lazily compute branches for a target label and throw. e.g. if an invalid target
    // label is applied, we want to exit the script gracefully with an error message.
    try {
        const targetLabels = await (0, labels_1.getTargetLabelsForActiveReleaseTrains)(api, config);
        const matchingLabel = await getMatchingTargetLabelForPullRequest(config.pullRequest, labelsOnPullRequest, targetLabels);
        const targetBranches = await getBranchesFromTargetLabel(matchingLabel, githubTargetBranch);
        (0, validations_1.assertChangesAllowForTargetLabel)(commits, matchingLabel, config.pullRequest);
        return targetBranches;
    }
    catch (error) {
        if (error instanceof InvalidTargetBranchError || error instanceof InvalidTargetLabelError) {
            throw new failures_1.PullRequestFailure(error.failureMessage);
        }
        throw error;
    }
}
exports.getTargetBranchesForPullRequest = getTargetBranchesForPullRequest;
/**
 * Gets the branches from the specified target label.
 *
 * @throws {InvalidTargetLabelError} Invalid label has been applied to pull request.
 * @throws {InvalidTargetBranchError} Invalid Github target branch has been selected.
 */
async function getBranchesFromTargetLabel(label, githubTargetBranch) {
    return typeof label.branches === 'function'
        ? await label.branches(githubTargetBranch)
        : await label.branches;
}
exports.getBranchesFromTargetLabel = getBranchesFromTargetLabel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFyZ2V0LWxhYmVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbmctZGV2L3ByL2NvbW1vbi90YXJnZXRpbmcvdGFyZ2V0LWxhYmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7OztBQUdILHFDQUErRDtBQUcvRCwyREFBMkU7QUFDM0UscURBQTBEO0FBRzFEOzs7Ozs7R0FNRztBQUNILElBQVksZUFNWDtBQU5ELFdBQVksZUFBZTtJQUN6QiwwQ0FBdUIsQ0FBQTtJQUN2QiwwQ0FBdUIsQ0FBQTtJQUN2QiwwQ0FBdUIsQ0FBQTtJQUN2QixtREFBZ0MsQ0FBQTtJQUNoQyxvREFBaUMsQ0FBQTtBQUNuQyxDQUFDLEVBTlcsZUFBZSxHQUFmLHVCQUFlLEtBQWYsdUJBQWUsUUFNMUI7QUFvQkQ7OztHQUdHO0FBQ0gsTUFBYSx3QkFBd0I7SUFDbkMsWUFBbUIsY0FBc0I7UUFBdEIsbUJBQWMsR0FBZCxjQUFjLENBQVE7SUFBRyxDQUFDO0NBQzlDO0FBRkQsNERBRUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFhLHVCQUF1QjtJQUNsQyxZQUFtQixjQUFzQjtRQUF0QixtQkFBYyxHQUFkLGNBQWMsQ0FBUTtJQUFHLENBQUM7Q0FDOUM7QUFGRCwwREFFQztBQUVELG9FQUFvRTtBQUM3RCxLQUFLLFVBQVUsb0NBQW9DLENBQ3hELE1BQW1ELEVBQ25ELG1CQUE2QixFQUM3QixlQUE4QjtJQUU5QixJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtRQUMzQixNQUFNLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0tBQzNEO0lBRUQsTUFBTSxPQUFPLEdBQWtCLEVBQUUsQ0FBQztJQUVsQyxLQUFLLE1BQU0sS0FBSyxJQUFJLG1CQUFtQixFQUFFO1FBQ3ZDLE1BQU0sS0FBSyxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFDLElBQUksRUFBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLENBQUM7UUFDL0QsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDckI7S0FDRjtJQUNELElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDeEIsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbkI7SUFDRCxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3hCLE1BQU0sSUFBSSx1QkFBdUIsQ0FDL0Isa0VBQWtFLENBQ25FLENBQUM7S0FDSDtJQUNELE1BQU0sSUFBSSx1QkFBdUIsQ0FDL0IseUVBQXlFLENBQzFFLENBQUM7QUFDSixDQUFDO0FBNUJELG9GQTRCQztBQUVELCtEQUErRDtBQUN4RCxLQUFLLFVBQVUsK0JBQStCLENBQ25ELEdBQWlCLEVBQ2pCLE1BQThELEVBQzlELG1CQUE2QixFQUM3QixrQkFBMEIsRUFDMUIsT0FBaUI7SUFFakIsSUFBSSxNQUFNLENBQUMsV0FBVyxDQUFDLGdCQUFnQixFQUFFO1FBQ3ZDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQ3ZDO0lBRUQsK0VBQStFO0lBQy9FLHVGQUF1RjtJQUN2RixzRkFBc0Y7SUFDdEYsaUZBQWlGO0lBQ2pGLElBQUk7UUFDRixNQUFNLFlBQVksR0FBRyxNQUFNLElBQUEsOENBQXFDLEVBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzlFLE1BQU0sYUFBYSxHQUFHLE1BQU0sb0NBQW9DLENBQzlELE1BQU0sQ0FBQyxXQUFXLEVBQ2xCLG1CQUFtQixFQUNuQixZQUFZLENBQ2IsQ0FBQztRQUNGLE1BQU0sY0FBYyxHQUFHLE1BQU0sMEJBQTBCLENBQUMsYUFBYSxFQUFFLGtCQUFrQixDQUFDLENBQUM7UUFFM0YsSUFBQSw4Q0FBZ0MsRUFBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUU3RSxPQUFPLGNBQWMsQ0FBQztLQUN2QjtJQUFDLE9BQU8sS0FBSyxFQUFFO1FBQ2QsSUFBSSxLQUFLLFlBQVksd0JBQXdCLElBQUksS0FBSyxZQUFZLHVCQUF1QixFQUFFO1lBQ3pGLE1BQU0sSUFBSSw2QkFBa0IsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDcEQ7UUFDRCxNQUFNLEtBQUssQ0FBQztLQUNiO0FBQ0gsQ0FBQztBQWpDRCwwRUFpQ0M7QUFFRDs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSwwQkFBMEIsQ0FDOUMsS0FBa0IsRUFDbEIsa0JBQTBCO0lBRTFCLE9BQU8sT0FBTyxLQUFLLENBQUMsUUFBUSxLQUFLLFVBQVU7UUFDekMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQztRQUMxQyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDO0FBQzNCLENBQUM7QUFQRCxnRUFPQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1B1bGxSZXF1ZXN0Q29uZmlnfSBmcm9tICcuLi8uLi9jb25maWcnO1xuaW1wb3J0IHtnZXRUYXJnZXRMYWJlbHNGb3JBY3RpdmVSZWxlYXNlVHJhaW5zfSBmcm9tICcuL2xhYmVscyc7XG5pbXBvcnQge0dpdGh1YkNvbmZpZ30gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY29uZmlnJztcbmltcG9ydCB7Q29tbWl0fSBmcm9tICcuLi8uLi8uLi9jb21taXQtbWVzc2FnZS9wYXJzZSc7XG5pbXBvcnQge2Fzc2VydENoYW5nZXNBbGxvd0ZvclRhcmdldExhYmVsfSBmcm9tICcuLi92YWxpZGF0aW9uL3ZhbGlkYXRpb25zJztcbmltcG9ydCB7UHVsbFJlcXVlc3RGYWlsdXJlfSBmcm9tICcuLi92YWxpZGF0aW9uL2ZhaWx1cmVzJztcbmltcG9ydCB7R2l0aHViQ2xpZW50fSBmcm9tICcuLi8uLi8uLi91dGlscy9naXQvZ2l0aHViJztcblxuLyoqXG4gKiBFbnVtIGNhcHR1cmluZyBhdmFpbGFibGUgdGFyZ2V0IGxhYmVsIG5hbWVzIGluIHRoZSBBbmd1bGFyIG9yZ2FuaXphdGlvbi4gQSB0YXJnZXRcbiAqIGxhYmVsIGlzIHNldCBvbiBhIHB1bGwgcmVxdWVzdCB0byBzcGVjaWZ5IHdoZXJlIGl0cyBjaGFuZ2VzIHNob3VsZCBsYW5kLlxuICpcbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZTpcbiAqIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMTk3a1ZpbGxEd3gtUlp0U1ZPQnRQYjRCQklBdzBFOVJUM3EzdjZEWmt5a1UjaGVhZGluZz1oLmxrdXlwajM4aDE1ZFxuICovXG5leHBvcnQgZW51bSBUYXJnZXRMYWJlbE5hbWUge1xuICBNQUpPUiA9ICd0YXJnZXQ6IG1ham9yJyxcbiAgTUlOT1IgPSAndGFyZ2V0OiBtaW5vcicsXG4gIFBBVENIID0gJ3RhcmdldDogcGF0Y2gnLFxuICBSRUxFQVNFX0NBTkRJREFURSA9ICd0YXJnZXQ6IHJjJyxcbiAgTE9OR19URVJNX1NVUFBPUlQgPSAndGFyZ2V0OiBsdHMnLFxufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIGxhYmVsIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gYSBwdWxsIHJlcXVlc3QgdG8gbWFyayBpbnRvXG4gKiB3aGljaCBicmFuY2hlcyBpdCBzaG91bGQgYmUgbWVyZ2VkIGludG8uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFyZ2V0TGFiZWwge1xuICAvKiogTmFtZSBvZiB0aGUgdGFyZ2V0IGxhYmVsLiBOZWVkcyB0byBtYXRjaCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBsYWJlbCBvbiBHaXRodWIuICovXG4gIG5hbWU6IFRhcmdldExhYmVsTmFtZTtcbiAgLyoqXG4gICAqIExpc3Qgb2YgYnJhbmNoZXMgYSBwdWxsIHJlcXVlc3Qgd2l0aCB0aGlzIHRhcmdldCBsYWJlbCBzaG91bGQgYmUgbWVyZ2VkIGludG8uXG4gICAqIENhbiBhbHNvIGJlIHdyYXBwZWQgaW4gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHRhcmdldCBicmFuY2ggc3BlY2lmaWVkIGluIHRoZVxuICAgKiBHaXRodWIgV2ViIFVJLiBUaGlzIGlzIHVzZWZ1bCBmb3Igc3VwcG9ydGluZyBsYWJlbHMgbGlrZSBgdGFyZ2V0OiBkZXZlbG9wbWVudC1icmFuY2hgLlxuICAgKlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvcn0gSW52YWxpZCBsYWJlbCBoYXMgYmVlbiBhcHBsaWVkIHRvIHB1bGwgcmVxdWVzdC5cbiAgICogQHRocm93cyB7SW52YWxpZFRhcmdldEJyYW5jaEVycm9yfSBJbnZhbGlkIEdpdGh1YiB0YXJnZXQgYnJhbmNoIGhhcyBiZWVuIHNlbGVjdGVkLlxuICAgKi9cbiAgYnJhbmNoZXM6IChnaXRodWJUYXJnZXRCcmFuY2g6IHN0cmluZykgPT4gc3RyaW5nW10gfCBQcm9taXNlPHN0cmluZ1tdPjtcbn1cblxuLyoqXG4gKiBVbmlxdWUgZXJyb3IgdGhhdCBjYW4gYmUgdGhyb3duIGluIHRoZSBtZXJnZSBjb25maWd1cmF0aW9uIGlmIGFuXG4gKiBpbnZhbGlkIGJyYW5jaCBpcyB0YXJnZXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRUYXJnZXRCcmFuY2hFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWlsdXJlTWVzc2FnZTogc3RyaW5nKSB7fVxufVxuXG4vKipcbiAqIFVuaXF1ZSBlcnJvciB0aGF0IGNhbiBiZSB0aHJvd24gaW4gdGhlIG1lcmdlIGNvbmZpZ3VyYXRpb24gaWYgYW5cbiAqIGludmFsaWQgbGFiZWwgaGFzIGJlZW4gYXBwbGllZCB0byBhIHB1bGwgcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRUYXJnZXRMYWJlbEVycm9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIGZhaWx1cmVNZXNzYWdlOiBzdHJpbmcpIHt9XG59XG5cbi8qKiBHZXRzIHRoZSB0YXJnZXQgbGFiZWwgZnJvbSB0aGUgc3BlY2lmaWVkIHB1bGwgcmVxdWVzdCBsYWJlbHMuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TWF0Y2hpbmdUYXJnZXRMYWJlbEZvclB1bGxSZXF1ZXN0KFxuICBjb25maWc6IFBpY2s8UHVsbFJlcXVlc3RDb25maWcsICdub1RhcmdldExhYmVsaW5nJz4sXG4gIGxhYmVsc09uUHVsbFJlcXVlc3Q6IHN0cmluZ1tdLFxuICBhbGxUYXJnZXRMYWJlbHM6IFRhcmdldExhYmVsW10sXG4pOiBQcm9taXNlPFRhcmdldExhYmVsPiB7XG4gIGlmIChjb25maWcubm9UYXJnZXRMYWJlbGluZykge1xuICAgIHRocm93IEVycm9yKCdUaGlzIHJlcG9zaXRvcnkgZG9lcyBub3QgdXNlIHRhcmdldCBsYWJlbHMnKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXM6IFRhcmdldExhYmVsW10gPSBbXTtcblxuICBmb3IgKGNvbnN0IGxhYmVsIG9mIGxhYmVsc09uUHVsbFJlcXVlc3QpIHtcbiAgICBjb25zdCBtYXRjaCA9IGFsbFRhcmdldExhYmVscy5maW5kKCh7bmFtZX0pID0+IGxhYmVsID09PSBuYW1lKTtcbiAgICBpZiAobWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbMF07XG4gIH1cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUYXJnZXRMYWJlbEVycm9yKFxuICAgICAgJ1VuYWJsZSB0byBkZXRlcm1pbmUgdGFyZ2V0IGZvciB0aGUgUFIgYXMgaXQgaGFzIG5vIHRhcmdldCBsYWJlbC4nLFxuICAgICk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWRUYXJnZXRMYWJlbEVycm9yKFxuICAgICdVbmFibGUgdG8gZGV0ZXJtaW5lIHRhcmdldCBmb3IgdGhlIFBSIGFzIGl0IGhhcyBtdWx0aXBsZSB0YXJnZXQgbGFiZWxzLicsXG4gICk7XG59XG5cbi8qKiBHZXQgdGhlIGJyYW5jaGVzIHRoZSBwdWxsIHJlcXVlc3Qgc2hvdWxkIGJlIG1lcmdlZCBpbnRvLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRhcmdldEJyYW5jaGVzRm9yUHVsbFJlcXVlc3QoXG4gIGFwaTogR2l0aHViQ2xpZW50LFxuICBjb25maWc6IHtwdWxsUmVxdWVzdDogUHVsbFJlcXVlc3RDb25maWc7IGdpdGh1YjogR2l0aHViQ29uZmlnfSxcbiAgbGFiZWxzT25QdWxsUmVxdWVzdDogc3RyaW5nW10sXG4gIGdpdGh1YlRhcmdldEJyYW5jaDogc3RyaW5nLFxuICBjb21taXRzOiBDb21taXRbXSxcbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgaWYgKGNvbmZpZy5wdWxsUmVxdWVzdC5ub1RhcmdldExhYmVsaW5nKSB7XG4gICAgcmV0dXJuIFtjb25maWcuZ2l0aHViLm1haW5CcmFuY2hOYW1lXTtcbiAgfVxuXG4gIC8vIElmIGJyYW5jaGVzIGFyZSBkZXRlcm1pbmVkIGZvciBhIGdpdmVuIHRhcmdldCBsYWJlbCwgY2FwdHVyZSBlcnJvcnMgdGhhdCBhcmVcbiAgLy8gdGhyb3duIGFzIHBhcnQgb2YgYnJhbmNoIGNvbXB1dGF0aW9uLiBUaGlzIGlzIGV4cGVjdGVkIGJlY2F1c2UgYSBtZXJnZSBjb25maWd1cmF0aW9uXG4gIC8vIGNhbiBsYXppbHkgY29tcHV0ZSBicmFuY2hlcyBmb3IgYSB0YXJnZXQgbGFiZWwgYW5kIHRocm93LiBlLmcuIGlmIGFuIGludmFsaWQgdGFyZ2V0XG4gIC8vIGxhYmVsIGlzIGFwcGxpZWQsIHdlIHdhbnQgdG8gZXhpdCB0aGUgc2NyaXB0IGdyYWNlZnVsbHkgd2l0aCBhbiBlcnJvciBtZXNzYWdlLlxuICB0cnkge1xuICAgIGNvbnN0IHRhcmdldExhYmVscyA9IGF3YWl0IGdldFRhcmdldExhYmVsc0ZvckFjdGl2ZVJlbGVhc2VUcmFpbnMoYXBpLCBjb25maWcpO1xuICAgIGNvbnN0IG1hdGNoaW5nTGFiZWwgPSBhd2FpdCBnZXRNYXRjaGluZ1RhcmdldExhYmVsRm9yUHVsbFJlcXVlc3QoXG4gICAgICBjb25maWcucHVsbFJlcXVlc3QsXG4gICAgICBsYWJlbHNPblB1bGxSZXF1ZXN0LFxuICAgICAgdGFyZ2V0TGFiZWxzLFxuICAgICk7XG4gICAgY29uc3QgdGFyZ2V0QnJhbmNoZXMgPSBhd2FpdCBnZXRCcmFuY2hlc0Zyb21UYXJnZXRMYWJlbChtYXRjaGluZ0xhYmVsLCBnaXRodWJUYXJnZXRCcmFuY2gpO1xuXG4gICAgYXNzZXJ0Q2hhbmdlc0FsbG93Rm9yVGFyZ2V0TGFiZWwoY29tbWl0cywgbWF0Y2hpbmdMYWJlbCwgY29uZmlnLnB1bGxSZXF1ZXN0KTtcblxuICAgIHJldHVybiB0YXJnZXRCcmFuY2hlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJbnZhbGlkVGFyZ2V0QnJhbmNoRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFB1bGxSZXF1ZXN0RmFpbHVyZShlcnJvci5mYWlsdXJlTWVzc2FnZSk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYnJhbmNoZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHRhcmdldCBsYWJlbC5cbiAqXG4gKiBAdGhyb3dzIHtJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvcn0gSW52YWxpZCBsYWJlbCBoYXMgYmVlbiBhcHBsaWVkIHRvIHB1bGwgcmVxdWVzdC5cbiAqIEB0aHJvd3Mge0ludmFsaWRUYXJnZXRCcmFuY2hFcnJvcn0gSW52YWxpZCBHaXRodWIgdGFyZ2V0IGJyYW5jaCBoYXMgYmVlbiBzZWxlY3RlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyYW5jaGVzRnJvbVRhcmdldExhYmVsKFxuICBsYWJlbDogVGFyZ2V0TGFiZWwsXG4gIGdpdGh1YlRhcmdldEJyYW5jaDogc3RyaW5nLFxuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICByZXR1cm4gdHlwZW9mIGxhYmVsLmJyYW5jaGVzID09PSAnZnVuY3Rpb24nXG4gICAgPyBhd2FpdCBsYWJlbC5icmFuY2hlcyhnaXRodWJUYXJnZXRCcmFuY2gpXG4gICAgOiBhd2FpdCBsYWJlbC5icmFuY2hlcztcbn1cbiJdfQ==