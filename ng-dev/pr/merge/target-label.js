"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBranchesFromTargetLabel = exports.getTargetLabelFromPullRequest = exports.InvalidTargetLabelError = exports.InvalidTargetBranchError = void 0;
const labels_1 = require("./defaults/labels");
const string_pattern_1 = require("./string-pattern");
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid branch is targeted.
 */
class InvalidTargetBranchError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetBranchError = InvalidTargetBranchError;
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid label has been applied to a pull request.
 */
class InvalidTargetLabelError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetLabelError = InvalidTargetLabelError;
/** Gets the target label from the specified pull request labels. */
async function getTargetLabelFromPullRequest(config, labels) {
    if (config.noTargetLabeling) {
        throw Error('This repository does not use target labels');
    }
    const targetLabels = await labels_1.getTargetLabels();
    /** List of discovered target labels for the PR. */
    const matches = [];
    for (const label of labels) {
        const match = targetLabels.find(({ pattern }) => string_pattern_1.matchesPattern(label, pattern));
        if (match !== undefined) {
            matches.push(match);
        }
    }
    if (matches.length === 1) {
        return matches[0];
    }
    if (matches.length === 0) {
        throw new InvalidTargetLabelError('Unable to determine target for the PR as it has no target label.');
    }
    throw new InvalidTargetLabelError('Unable to determine target for the PR as it has multiple target labels.');
}
exports.getTargetLabelFromPullRequest = getTargetLabelFromPullRequest;
/**
 * Gets the branches from the specified target label.
 *
 * @throws {InvalidTargetLabelError} Invalid label has been applied to pull request.
 * @throws {InvalidTargetBranchError} Invalid Github target branch has been selected.
 */
async function getBranchesFromTargetLabel(label, githubTargetBranch) {
    return typeof label.branches === 'function'
        ? await label.branches(githubTargetBranch)
        : await label.branches;
}
exports.getBranchesFromTargetLabel = getBranchesFromTargetLabel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFyZ2V0LWxhYmVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbmctZGV2L3ByL21lcmdlL3RhcmdldC1sYWJlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HOzs7QUFHSCw4Q0FBa0Q7QUFDbEQscURBQWdEO0FBRWhEOzs7R0FHRztBQUNILE1BQWEsd0JBQXdCO0lBQ25DLFlBQW1CLGNBQXNCO1FBQXRCLG1CQUFjLEdBQWQsY0FBYyxDQUFRO0lBQUcsQ0FBQztDQUM5QztBQUZELDREQUVDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBYSx1QkFBdUI7SUFDbEMsWUFBbUIsY0FBc0I7UUFBdEIsbUJBQWMsR0FBZCxjQUFjLENBQVE7SUFBRyxDQUFDO0NBQzlDO0FBRkQsMERBRUM7QUFFRCxvRUFBb0U7QUFDN0QsS0FBSyxVQUFVLDZCQUE2QixDQUNqRCxNQUE2QyxFQUM3QyxNQUFnQjtJQUVoQixJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtRQUMzQixNQUFNLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0tBQzNEO0lBRUQsTUFBTSxZQUFZLEdBQUcsTUFBTSx3QkFBZSxFQUFFLENBQUM7SUFDN0MsbURBQW1EO0lBQ25ELE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztJQUNuQixLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRTtRQUMxQixNQUFNLEtBQUssR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBQyxPQUFPLEVBQUMsRUFBRSxFQUFFLENBQUMsK0JBQWMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUMvRSxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDdkIsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNyQjtLQUNGO0lBQ0QsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN4QixPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNuQjtJQUNELElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDeEIsTUFBTSxJQUFJLHVCQUF1QixDQUMvQixrRUFBa0UsQ0FDbkUsQ0FBQztLQUNIO0lBQ0QsTUFBTSxJQUFJLHVCQUF1QixDQUMvQix5RUFBeUUsQ0FDMUUsQ0FBQztBQUNKLENBQUM7QUE1QkQsc0VBNEJDO0FBRUQ7Ozs7O0dBS0c7QUFDSSxLQUFLLFVBQVUsMEJBQTBCLENBQzlDLEtBQWtCLEVBQ2xCLGtCQUEwQjtJQUUxQixPQUFPLE9BQU8sS0FBSyxDQUFDLFFBQVEsS0FBSyxVQUFVO1FBQ3pDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUM7UUFDMUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLFFBQVEsQ0FBQztBQUMzQixDQUFDO0FBUEQsZ0VBT0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtNZXJnZUNvbmZpZywgVGFyZ2V0TGFiZWx9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7Z2V0VGFyZ2V0TGFiZWxzfSBmcm9tICcuL2RlZmF1bHRzL2xhYmVscyc7XG5pbXBvcnQge21hdGNoZXNQYXR0ZXJufSBmcm9tICcuL3N0cmluZy1wYXR0ZXJuJztcblxuLyoqXG4gKiBVbmlxdWUgZXJyb3IgdGhhdCBjYW4gYmUgdGhyb3duIGluIHRoZSBtZXJnZSBjb25maWd1cmF0aW9uIGlmIGFuXG4gKiBpbnZhbGlkIGJyYW5jaCBpcyB0YXJnZXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRUYXJnZXRCcmFuY2hFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWlsdXJlTWVzc2FnZTogc3RyaW5nKSB7fVxufVxuXG4vKipcbiAqIFVuaXF1ZSBlcnJvciB0aGF0IGNhbiBiZSB0aHJvd24gaW4gdGhlIG1lcmdlIGNvbmZpZ3VyYXRpb24gaWYgYW5cbiAqIGludmFsaWQgbGFiZWwgaGFzIGJlZW4gYXBwbGllZCB0byBhIHB1bGwgcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRUYXJnZXRMYWJlbEVycm9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIGZhaWx1cmVNZXNzYWdlOiBzdHJpbmcpIHt9XG59XG5cbi8qKiBHZXRzIHRoZSB0YXJnZXQgbGFiZWwgZnJvbSB0aGUgc3BlY2lmaWVkIHB1bGwgcmVxdWVzdCBsYWJlbHMuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxGcm9tUHVsbFJlcXVlc3QoXG4gIGNvbmZpZzogUGljazxNZXJnZUNvbmZpZywgJ25vVGFyZ2V0TGFiZWxpbmcnPixcbiAgbGFiZWxzOiBzdHJpbmdbXSxcbik6IFByb21pc2U8VGFyZ2V0TGFiZWw+IHtcbiAgaWYgKGNvbmZpZy5ub1RhcmdldExhYmVsaW5nKSB7XG4gICAgdGhyb3cgRXJyb3IoJ1RoaXMgcmVwb3NpdG9yeSBkb2VzIG5vdCB1c2UgdGFyZ2V0IGxhYmVscycpO1xuICB9XG5cbiAgY29uc3QgdGFyZ2V0TGFiZWxzID0gYXdhaXQgZ2V0VGFyZ2V0TGFiZWxzKCk7XG4gIC8qKiBMaXN0IG9mIGRpc2NvdmVyZWQgdGFyZ2V0IGxhYmVscyBmb3IgdGhlIFBSLiAqL1xuICBjb25zdCBtYXRjaGVzID0gW107XG4gIGZvciAoY29uc3QgbGFiZWwgb2YgbGFiZWxzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0YXJnZXRMYWJlbHMuZmluZCgoe3BhdHRlcm59KSA9PiBtYXRjaGVzUGF0dGVybihsYWJlbCwgcGF0dGVybikpO1xuICAgIGlmIChtYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1swXTtcbiAgfVxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRhcmdldExhYmVsRXJyb3IoXG4gICAgICAnVW5hYmxlIHRvIGRldGVybWluZSB0YXJnZXQgZm9yIHRoZSBQUiBhcyBpdCBoYXMgbm8gdGFyZ2V0IGxhYmVsLicsXG4gICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZFRhcmdldExhYmVsRXJyb3IoXG4gICAgJ1VuYWJsZSB0byBkZXRlcm1pbmUgdGFyZ2V0IGZvciB0aGUgUFIgYXMgaXQgaGFzIG11bHRpcGxlIHRhcmdldCBsYWJlbHMuJyxcbiAgKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBicmFuY2hlcyBmcm9tIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGxhYmVsLlxuICpcbiAqIEB0aHJvd3Mge0ludmFsaWRUYXJnZXRMYWJlbEVycm9yfSBJbnZhbGlkIGxhYmVsIGhhcyBiZWVuIGFwcGxpZWQgdG8gcHVsbCByZXF1ZXN0LlxuICogQHRocm93cyB7SW52YWxpZFRhcmdldEJyYW5jaEVycm9yfSBJbnZhbGlkIEdpdGh1YiB0YXJnZXQgYnJhbmNoIGhhcyBiZWVuIHNlbGVjdGVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QnJhbmNoZXNGcm9tVGFyZ2V0TGFiZWwoXG4gIGxhYmVsOiBUYXJnZXRMYWJlbCxcbiAgZ2l0aHViVGFyZ2V0QnJhbmNoOiBzdHJpbmcsXG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIHJldHVybiB0eXBlb2YgbGFiZWwuYnJhbmNoZXMgPT09ICdmdW5jdGlvbidcbiAgICA/IGF3YWl0IGxhYmVsLmJyYW5jaGVzKGdpdGh1YlRhcmdldEJyYW5jaClcbiAgICA6IGF3YWl0IGxhYmVsLmJyYW5jaGVzO1xufVxuIl19