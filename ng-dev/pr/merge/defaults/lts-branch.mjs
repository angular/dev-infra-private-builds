"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertActiveLtsBranch = void 0;
const semver = require("semver");
const versioning_1 = require("../../../release/versioning");
const console_1 = require("../../../utils/console");
const target_label_1 = require("../target-label");
const locale_1 = require("../../../utils/locale");
/**
 * Asserts that the given branch corresponds to an active LTS version-branch that can receive
 * backport fixes. Throws an error if LTS expired or an invalid branch is selected.
 *
 * @param repo Repository containing the given branch. Used for Github API queries.
 * @param releaseConfig Configuration for releases. Used to query NPM about past publishes.
 * @param branchName Branch that is checked to be an active LTS version-branch.
 * */
async function assertActiveLtsBranch(repo, releaseConfig, branchName) {
    const version = await versioning_1.getVersionOfBranch(repo, branchName);
    const { 'dist-tags': distTags, time } = await versioning_1.fetchProjectNpmPackageInfo(releaseConfig);
    // LTS versions should be tagged in NPM in the following format: `v{major}-lts`.
    const ltsNpmTag = versioning_1.getLtsNpmDistTagOfMajor(version.major);
    const ltsVersion = semver.parse(distTags[ltsNpmTag]);
    // Ensure that there is an LTS version tagged for the given version-branch major. e.g.
    // if the version branch is `9.2.x` then we want to make sure that there is an LTS
    // version tagged in NPM for `v9`, following the `v{major}-lts` tag convention.
    if (ltsVersion === null) {
        throw new target_label_1.InvalidTargetBranchError(`No LTS version tagged for v${version.major} in NPM.`);
    }
    // Ensure that the correct branch is used for the LTS version. We do not want to merge
    // changes to older minor version branches that do not reflect the current LTS version.
    if (branchName !== `${ltsVersion.major}.${ltsVersion.minor}.x`) {
        throw new target_label_1.InvalidTargetBranchError(`Not using last-minor branch for v${version.major} LTS version. PR ` +
            `should be updated to target: ${ltsVersion.major}.${ltsVersion.minor}.x`);
    }
    const today = new Date();
    const majorReleaseDate = new Date(time[`${version.major}.0.0`]);
    const ltsEndDate = versioning_1.computeLtsEndDateOfMajor(majorReleaseDate);
    // Check if LTS has already expired for the targeted major version. If so, we do not
    // allow the merge as per our LTS guarantees. Can be forcibly overridden if desired.
    // See: https://angular.io/guide/releases#support-policy-and-schedule.
    if (today > ltsEndDate) {
        const ltsEndDateText = ltsEndDate.toLocaleDateString(locale_1.defaultLocale);
        console_1.warn(console_1.red(`Long-term support ended for v${version.major} on ${ltsEndDateText}.`));
        console_1.warn(console_1.yellow(`Merging of pull requests for this major is generally not ` +
            `desired, but can be forcibly ignored.`));
        if (await console_1.promptConfirm('Do you want to forcibly proceed with merging?')) {
            return;
        }
        throw new target_label_1.InvalidTargetBranchError(`Long-term supported ended for v${version.major} on ${ltsEndDateText}. ` +
            `Pull request cannot be merged into the ${branchName} branch.`);
    }
}
exports.assertActiveLtsBranch = assertActiveLtsBranch;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHRzLWJyYW5jaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL25nLWRldi9wci9tZXJnZS9kZWZhdWx0cy9sdHMtYnJhbmNoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7O0dBTUc7OztBQUVILGlDQUFpQztBQUdqQyw0REFNcUM7QUFDckMsb0RBQXdFO0FBQ3hFLGtEQUF5RDtBQUN6RCxrREFBb0Q7QUFFcEQ7Ozs7Ozs7S0FPSztBQUNFLEtBQUssVUFBVSxxQkFBcUIsQ0FDekMsSUFBd0IsRUFDeEIsYUFBNEIsRUFDNUIsVUFBa0I7SUFFbEIsTUFBTSxPQUFPLEdBQUcsTUFBTSwrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDM0QsTUFBTSxFQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFDLEdBQUcsTUFBTSx1Q0FBMEIsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUV0RixnRkFBZ0Y7SUFDaEYsTUFBTSxTQUFTLEdBQUcsb0NBQXVCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pELE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFFckQsc0ZBQXNGO0lBQ3RGLGtGQUFrRjtJQUNsRiwrRUFBK0U7SUFDL0UsSUFBSSxVQUFVLEtBQUssSUFBSSxFQUFFO1FBQ3ZCLE1BQU0sSUFBSSx1Q0FBd0IsQ0FBQyw4QkFBOEIsT0FBTyxDQUFDLEtBQUssVUFBVSxDQUFDLENBQUM7S0FDM0Y7SUFFRCxzRkFBc0Y7SUFDdEYsdUZBQXVGO0lBQ3ZGLElBQUksVUFBVSxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssSUFBSSxVQUFVLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDOUQsTUFBTSxJQUFJLHVDQUF3QixDQUNoQyxvQ0FBb0MsT0FBTyxDQUFDLEtBQUssbUJBQW1CO1lBQ2xFLGdDQUFnQyxVQUFVLENBQUMsS0FBSyxJQUFJLFVBQVUsQ0FBQyxLQUFLLElBQUksQ0FDM0UsQ0FBQztLQUNIO0lBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztJQUN6QixNQUFNLGdCQUFnQixHQUFHLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDaEUsTUFBTSxVQUFVLEdBQUcscUNBQXdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUU5RCxvRkFBb0Y7SUFDcEYsb0ZBQW9GO0lBQ3BGLHNFQUFzRTtJQUN0RSxJQUFJLEtBQUssR0FBRyxVQUFVLEVBQUU7UUFDdEIsTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLGtCQUFrQixDQUFDLHNCQUFhLENBQUMsQ0FBQztRQUNwRSxjQUFJLENBQUMsYUFBRyxDQUFDLGdDQUFnQyxPQUFPLENBQUMsS0FBSyxPQUFPLGNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNqRixjQUFJLENBQ0YsZ0JBQU0sQ0FDSiwyREFBMkQ7WUFDekQsdUNBQXVDLENBQzFDLENBQ0YsQ0FBQztRQUNGLElBQUksTUFBTSx1QkFBYSxDQUFDLCtDQUErQyxDQUFDLEVBQUU7WUFDeEUsT0FBTztTQUNSO1FBQ0QsTUFBTSxJQUFJLHVDQUF3QixDQUNoQyxrQ0FBa0MsT0FBTyxDQUFDLEtBQUssT0FBTyxjQUFjLElBQUk7WUFDdEUsMENBQTBDLFVBQVUsVUFBVSxDQUNqRSxDQUFDO0tBQ0g7QUFDSCxDQUFDO0FBcERELHNEQW9EQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuaW1wb3J0IHtSZWxlYXNlQ29uZmlnfSBmcm9tICcuLi8uLi8uLi9yZWxlYXNlL2NvbmZpZy9pbmRleCc7XG5pbXBvcnQge1xuICBjb21wdXRlTHRzRW5kRGF0ZU9mTWFqb3IsXG4gIGZldGNoUHJvamVjdE5wbVBhY2thZ2VJbmZvLFxuICBnZXRMdHNOcG1EaXN0VGFnT2ZNYWpvcixcbiAgZ2V0VmVyc2lvbk9mQnJhbmNoLFxuICBSZWxlYXNlUmVwb1dpdGhBcGksXG59IGZyb20gJy4uLy4uLy4uL3JlbGVhc2UvdmVyc2lvbmluZyc7XG5pbXBvcnQge3Byb21wdENvbmZpcm0sIHJlZCwgd2FybiwgeWVsbG93fSBmcm9tICcuLi8uLi8uLi91dGlscy9jb25zb2xlJztcbmltcG9ydCB7SW52YWxpZFRhcmdldEJyYW5jaEVycm9yfSBmcm9tICcuLi90YXJnZXQtbGFiZWwnO1xuaW1wb3J0IHtkZWZhdWx0TG9jYWxlfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2NhbGUnO1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gYnJhbmNoIGNvcnJlc3BvbmRzIHRvIGFuIGFjdGl2ZSBMVFMgdmVyc2lvbi1icmFuY2ggdGhhdCBjYW4gcmVjZWl2ZVxuICogYmFja3BvcnQgZml4ZXMuIFRocm93cyBhbiBlcnJvciBpZiBMVFMgZXhwaXJlZCBvciBhbiBpbnZhbGlkIGJyYW5jaCBpcyBzZWxlY3RlZC5cbiAqXG4gKiBAcGFyYW0gcmVwbyBSZXBvc2l0b3J5IGNvbnRhaW5pbmcgdGhlIGdpdmVuIGJyYW5jaC4gVXNlZCBmb3IgR2l0aHViIEFQSSBxdWVyaWVzLlxuICogQHBhcmFtIHJlbGVhc2VDb25maWcgQ29uZmlndXJhdGlvbiBmb3IgcmVsZWFzZXMuIFVzZWQgdG8gcXVlcnkgTlBNIGFib3V0IHBhc3QgcHVibGlzaGVzLlxuICogQHBhcmFtIGJyYW5jaE5hbWUgQnJhbmNoIHRoYXQgaXMgY2hlY2tlZCB0byBiZSBhbiBhY3RpdmUgTFRTIHZlcnNpb24tYnJhbmNoLlxuICogKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3NlcnRBY3RpdmVMdHNCcmFuY2goXG4gIHJlcG86IFJlbGVhc2VSZXBvV2l0aEFwaSxcbiAgcmVsZWFzZUNvbmZpZzogUmVsZWFzZUNvbmZpZyxcbiAgYnJhbmNoTmFtZTogc3RyaW5nLFxuKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBhd2FpdCBnZXRWZXJzaW9uT2ZCcmFuY2gocmVwbywgYnJhbmNoTmFtZSk7XG4gIGNvbnN0IHsnZGlzdC10YWdzJzogZGlzdFRhZ3MsIHRpbWV9ID0gYXdhaXQgZmV0Y2hQcm9qZWN0TnBtUGFja2FnZUluZm8ocmVsZWFzZUNvbmZpZyk7XG5cbiAgLy8gTFRTIHZlcnNpb25zIHNob3VsZCBiZSB0YWdnZWQgaW4gTlBNIGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBgdnttYWpvcn0tbHRzYC5cbiAgY29uc3QgbHRzTnBtVGFnID0gZ2V0THRzTnBtRGlzdFRhZ09mTWFqb3IodmVyc2lvbi5tYWpvcik7XG4gIGNvbnN0IGx0c1ZlcnNpb24gPSBzZW12ZXIucGFyc2UoZGlzdFRhZ3NbbHRzTnBtVGFnXSk7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYW4gTFRTIHZlcnNpb24gdGFnZ2VkIGZvciB0aGUgZ2l2ZW4gdmVyc2lvbi1icmFuY2ggbWFqb3IuIGUuZy5cbiAgLy8gaWYgdGhlIHZlcnNpb24gYnJhbmNoIGlzIGA5LjIueGAgdGhlbiB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZXJlIGlzIGFuIExUU1xuICAvLyB2ZXJzaW9uIHRhZ2dlZCBpbiBOUE0gZm9yIGB2OWAsIGZvbGxvd2luZyB0aGUgYHZ7bWFqb3J9LWx0c2AgdGFnIGNvbnZlbnRpb24uXG4gIGlmIChsdHNWZXJzaW9uID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUYXJnZXRCcmFuY2hFcnJvcihgTm8gTFRTIHZlcnNpb24gdGFnZ2VkIGZvciB2JHt2ZXJzaW9uLm1ham9yfSBpbiBOUE0uYCk7XG4gIH1cblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgY29ycmVjdCBicmFuY2ggaXMgdXNlZCBmb3IgdGhlIExUUyB2ZXJzaW9uLiBXZSBkbyBub3Qgd2FudCB0byBtZXJnZVxuICAvLyBjaGFuZ2VzIHRvIG9sZGVyIG1pbm9yIHZlcnNpb24gYnJhbmNoZXMgdGhhdCBkbyBub3QgcmVmbGVjdCB0aGUgY3VycmVudCBMVFMgdmVyc2lvbi5cbiAgaWYgKGJyYW5jaE5hbWUgIT09IGAke2x0c1ZlcnNpb24ubWFqb3J9LiR7bHRzVmVyc2lvbi5taW5vcn0ueGApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRhcmdldEJyYW5jaEVycm9yKFxuICAgICAgYE5vdCB1c2luZyBsYXN0LW1pbm9yIGJyYW5jaCBmb3IgdiR7dmVyc2lvbi5tYWpvcn0gTFRTIHZlcnNpb24uIFBSIGAgK1xuICAgICAgICBgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdGFyZ2V0OiAke2x0c1ZlcnNpb24ubWFqb3J9LiR7bHRzVmVyc2lvbi5taW5vcn0ueGAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgbWFqb3JSZWxlYXNlRGF0ZSA9IG5ldyBEYXRlKHRpbWVbYCR7dmVyc2lvbi5tYWpvcn0uMC4wYF0pO1xuICBjb25zdCBsdHNFbmREYXRlID0gY29tcHV0ZUx0c0VuZERhdGVPZk1ham9yKG1ham9yUmVsZWFzZURhdGUpO1xuXG4gIC8vIENoZWNrIGlmIExUUyBoYXMgYWxyZWFkeSBleHBpcmVkIGZvciB0aGUgdGFyZ2V0ZWQgbWFqb3IgdmVyc2lvbi4gSWYgc28sIHdlIGRvIG5vdFxuICAvLyBhbGxvdyB0aGUgbWVyZ2UgYXMgcGVyIG91ciBMVFMgZ3VhcmFudGVlcy4gQ2FuIGJlIGZvcmNpYmx5IG92ZXJyaWRkZW4gaWYgZGVzaXJlZC5cbiAgLy8gU2VlOiBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvcmVsZWFzZXMjc3VwcG9ydC1wb2xpY3ktYW5kLXNjaGVkdWxlLlxuICBpZiAodG9kYXkgPiBsdHNFbmREYXRlKSB7XG4gICAgY29uc3QgbHRzRW5kRGF0ZVRleHQgPSBsdHNFbmREYXRlLnRvTG9jYWxlRGF0ZVN0cmluZyhkZWZhdWx0TG9jYWxlKTtcbiAgICB3YXJuKHJlZChgTG9uZy10ZXJtIHN1cHBvcnQgZW5kZWQgZm9yIHYke3ZlcnNpb24ubWFqb3J9IG9uICR7bHRzRW5kRGF0ZVRleHR9LmApKTtcbiAgICB3YXJuKFxuICAgICAgeWVsbG93KFxuICAgICAgICBgTWVyZ2luZyBvZiBwdWxsIHJlcXVlc3RzIGZvciB0aGlzIG1ham9yIGlzIGdlbmVyYWxseSBub3QgYCArXG4gICAgICAgICAgYGRlc2lyZWQsIGJ1dCBjYW4gYmUgZm9yY2libHkgaWdub3JlZC5gLFxuICAgICAgKSxcbiAgICApO1xuICAgIGlmIChhd2FpdCBwcm9tcHRDb25maXJtKCdEbyB5b3Ugd2FudCB0byBmb3JjaWJseSBwcm9jZWVkIHdpdGggbWVyZ2luZz8nKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW52YWxpZFRhcmdldEJyYW5jaEVycm9yKFxuICAgICAgYExvbmctdGVybSBzdXBwb3J0ZWQgZW5kZWQgZm9yIHYke3ZlcnNpb24ubWFqb3J9IG9uICR7bHRzRW5kRGF0ZVRleHR9LiBgICtcbiAgICAgICAgYFB1bGwgcmVxdWVzdCBjYW5ub3QgYmUgbWVyZ2VkIGludG8gdGhlICR7YnJhbmNoTmFtZX0gYnJhbmNoLmAsXG4gICAgKTtcbiAgfVxufVxuIl19