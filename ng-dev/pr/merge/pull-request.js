"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPullRequest = exports.loadAndValidatePullRequest = void 0;
const parse_1 = require("../../commit-message/parse");
const failures_1 = require("../common/validation/failures");
const string_pattern_1 = require("./string-pattern");
const target_label_1 = require("../common/targeting/target-label");
const validations_1 = require("../common/validation/validations");
const fetch_pull_request_1 = require("../common/fetch-pull-request");
/**
 * Loads and validates the specified pull request against the given configuration.
 * If the pull requests fails, a pull request failure is returned.
 */
async function loadAndValidatePullRequest({ git, config }, prNumber, ignoreNonFatalFailures = false) {
    const prData = await (0, fetch_pull_request_1.fetchPullRequestFromGithub)(git, prNumber);
    if (prData === null) {
        return failures_1.PullRequestFailure.notFound();
    }
    const labels = prData.labels.nodes.map((l) => l.name);
    if (!labels.some((name) => (0, string_pattern_1.matchesPattern)(name, config.pullRequest.mergeReadyLabel))) {
        return failures_1.PullRequestFailure.notMergeReady();
    }
    if (!labels.some((name) => (0, string_pattern_1.matchesPattern)(name, config.pullRequest.claSignedLabel))) {
        return failures_1.PullRequestFailure.claUnsigned();
    }
    /** List of parsed commits for all of the commits in the pull request. */
    const commitsInPr = prData.commits.nodes.map((n) => (0, parse_1.parseCommitMessage)(n.commit.message));
    const githubTargetBranch = prData.baseRefName;
    const targetBranches = await (0, target_label_1.getTargetBranchesForPullRequest)(git.github, config, labels, githubTargetBranch, commitsInPr);
    try {
        (0, validations_1.assertPendingState)(prData);
        (0, validations_1.assertCorrectBreakingChangeLabeling)(commitsInPr, labels);
    }
    catch (error) {
        // If the error is a pull request failure, we pass it through gracefully
        // as the tool expects such failures to be returned from the function.
        if (error instanceof failures_1.PullRequestFailure) {
            return error;
        }
        throw error;
    }
    /** The combined status of the latest commit in the pull request. */
    const state = prData.commits.nodes.slice(-1)[0].commit.status.state;
    if (state === 'FAILURE' && !ignoreNonFatalFailures) {
        return failures_1.PullRequestFailure.failingCiJobs();
    }
    if (state === 'PENDING' && !ignoreNonFatalFailures) {
        return failures_1.PullRequestFailure.pendingCiJobs();
    }
    const requiredBaseSha = config.pullRequest.requiredBaseCommits &&
        config.pullRequest.requiredBaseCommits[githubTargetBranch];
    const needsCommitMessageFixup = !!config.pullRequest.commitMessageFixupLabel &&
        labels.some((name) => (0, string_pattern_1.matchesPattern)(name, config.pullRequest.commitMessageFixupLabel));
    const hasCaretakerNote = !!config.pullRequest.caretakerNoteLabel &&
        labels.some((name) => (0, string_pattern_1.matchesPattern)(name, config.pullRequest.caretakerNoteLabel));
    return {
        url: prData.url,
        prNumber,
        labels,
        requiredBaseSha,
        githubTargetBranch,
        needsCommitMessageFixup,
        hasCaretakerNote,
        targetBranches,
        title: prData.title,
        commitCount: prData.commits.totalCount,
    };
}
exports.loadAndValidatePullRequest = loadAndValidatePullRequest;
/** Whether the specified value resolves to a pull request. */
function isPullRequest(v) {
    return v.targetBranches !== undefined;
}
exports.isPullRequest = isPullRequest;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVsbC1yZXF1ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbmctZGV2L3ByL21lcmdlL3B1bGwtcmVxdWVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HOzs7QUFFSCxzREFBOEQ7QUFDOUQsNERBQWlFO0FBQ2pFLHFEQUFnRDtBQUVoRCxtRUFBaUY7QUFDakYsa0VBRzBDO0FBQzFDLHFFQUF3RTtBQTBCeEU7OztHQUdHO0FBQ0ksS0FBSyxVQUFVLDBCQUEwQixDQUM5QyxFQUFDLEdBQUcsRUFBRSxNQUFNLEVBQXVCLEVBQ25DLFFBQWdCLEVBQ2hCLHNCQUFzQixHQUFHLEtBQUs7SUFFOUIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFBLCtDQUEwQixFQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUUvRCxJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUU7UUFDbkIsT0FBTyw2QkFBa0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUN0QztJQUVELE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXRELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFBLCtCQUFjLEVBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRTtRQUNwRixPQUFPLDZCQUFrQixDQUFDLGFBQWEsRUFBRSxDQUFDO0tBQzNDO0lBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUEsK0JBQWMsRUFBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFO1FBQ25GLE9BQU8sNkJBQWtCLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDekM7SUFFRCx5RUFBeUU7SUFDekUsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFBLDBCQUFrQixFQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUMxRixNQUFNLGtCQUFrQixHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7SUFFOUMsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFBLDhDQUErQixFQUMxRCxHQUFHLENBQUMsTUFBTSxFQUNWLE1BQU0sRUFDTixNQUFNLEVBQ04sa0JBQWtCLEVBQ2xCLFdBQVcsQ0FDWixDQUFDO0lBRUYsSUFBSTtRQUNGLElBQUEsZ0NBQWtCLEVBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0IsSUFBQSxpREFBbUMsRUFBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDMUQ7SUFBQyxPQUFPLEtBQUssRUFBRTtRQUNkLHdFQUF3RTtRQUN4RSxzRUFBc0U7UUFDdEUsSUFBSSxLQUFLLFlBQVksNkJBQWtCLEVBQUU7WUFDdkMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE1BQU0sS0FBSyxDQUFDO0tBQ2I7SUFFRCxvRUFBb0U7SUFDcEUsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDcEUsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLENBQUMsc0JBQXNCLEVBQUU7UUFDbEQsT0FBTyw2QkFBa0IsQ0FBQyxhQUFhLEVBQUUsQ0FBQztLQUMzQztJQUNELElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxDQUFDLHNCQUFzQixFQUFFO1FBQ2xELE9BQU8sNkJBQWtCLENBQUMsYUFBYSxFQUFFLENBQUM7S0FDM0M7SUFFRCxNQUFNLGVBQWUsR0FDbkIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxtQkFBbUI7UUFDdEMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQzdELE1BQU0sdUJBQXVCLEdBQzNCLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLHVCQUF1QjtRQUM1QyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFBLCtCQUFjLEVBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDO0lBQzFGLE1BQU0sZ0JBQWdCLEdBQ3BCLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLGtCQUFrQjtRQUN2QyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFBLCtCQUFjLEVBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsa0JBQW1CLENBQUMsQ0FBQyxDQUFDO0lBRXRGLE9BQU87UUFDTCxHQUFHLEVBQUUsTUFBTSxDQUFDLEdBQUc7UUFDZixRQUFRO1FBQ1IsTUFBTTtRQUNOLGVBQWU7UUFDZixrQkFBa0I7UUFDbEIsdUJBQXVCO1FBQ3ZCLGdCQUFnQjtRQUNoQixjQUFjO1FBQ2QsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLO1FBQ25CLFdBQVcsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVU7S0FDdkMsQ0FBQztBQUNKLENBQUM7QUEzRUQsZ0VBMkVDO0FBRUQsOERBQThEO0FBQzlELFNBQWdCLGFBQWEsQ0FBQyxDQUFtQztJQUMvRCxPQUFRLENBQWlCLENBQUMsY0FBYyxLQUFLLFNBQVMsQ0FBQztBQUN6RCxDQUFDO0FBRkQsc0NBRUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtwYXJzZUNvbW1pdE1lc3NhZ2V9IGZyb20gJy4uLy4uL2NvbW1pdC1tZXNzYWdlL3BhcnNlJztcbmltcG9ydCB7UHVsbFJlcXVlc3RGYWlsdXJlfSBmcm9tICcuLi9jb21tb24vdmFsaWRhdGlvbi9mYWlsdXJlcyc7XG5pbXBvcnQge21hdGNoZXNQYXR0ZXJufSBmcm9tICcuL3N0cmluZy1wYXR0ZXJuJztcbmltcG9ydCB7UHVsbFJlcXVlc3RNZXJnZVRhc2t9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQge2dldFRhcmdldEJyYW5jaGVzRm9yUHVsbFJlcXVlc3R9IGZyb20gJy4uL2NvbW1vbi90YXJnZXRpbmcvdGFyZ2V0LWxhYmVsJztcbmltcG9ydCB7XG4gIGFzc2VydENvcnJlY3RCcmVha2luZ0NoYW5nZUxhYmVsaW5nLFxuICBhc3NlcnRQZW5kaW5nU3RhdGUsXG59IGZyb20gJy4uL2NvbW1vbi92YWxpZGF0aW9uL3ZhbGlkYXRpb25zJztcbmltcG9ydCB7ZmV0Y2hQdWxsUmVxdWVzdEZyb21HaXRodWJ9IGZyb20gJy4uL2NvbW1vbi9mZXRjaC1wdWxsLXJlcXVlc3QnO1xuXG4vKiogSW50ZXJmYWNlIHRoYXQgZGVzY3JpYmVzIGEgcHVsbCByZXF1ZXN0LiAqL1xuZXhwb3J0IGludGVyZmFjZSBQdWxsUmVxdWVzdCB7XG4gIC8qKiBVUkwgdG8gdGhlIHB1bGwgcmVxdWVzdC4gKi9cbiAgdXJsOiBzdHJpbmc7XG4gIC8qKiBOdW1iZXIgb2YgdGhlIHB1bGwgcmVxdWVzdC4gKi9cbiAgcHJOdW1iZXI6IG51bWJlcjtcbiAgLyoqIFRpdGxlIG9mIHRoZSBwdWxsIHJlcXVlc3QuICovXG4gIHRpdGxlOiBzdHJpbmc7XG4gIC8qKiBMYWJlbHMgYXBwbGllZCB0byB0aGUgcHVsbCByZXF1ZXN0LiAqL1xuICBsYWJlbHM6IHN0cmluZ1tdO1xuICAvKiogTGlzdCBvZiBicmFuY2hlcyB0aGlzIFBSIHNob3VsZCBiZSBtZXJnZWQgaW50by4gKi9cbiAgdGFyZ2V0QnJhbmNoZXM6IHN0cmluZ1tdO1xuICAvKiogQnJhbmNoIHRoYXQgdGhlIFBSIHRhcmdldHMgaW4gdGhlIEdpdGh1YiBVSS4gKi9cbiAgZ2l0aHViVGFyZ2V0QnJhbmNoOiBzdHJpbmc7XG4gIC8qKiBDb3VudCBvZiBjb21taXRzIGluIHRoaXMgcHVsbCByZXF1ZXN0LiAqL1xuICBjb21taXRDb3VudDogbnVtYmVyO1xuICAvKiogT3B0aW9uYWwgU0hBIHRoYXQgdGhpcyBwdWxsIHJlcXVlc3QgbmVlZHMgdG8gYmUgYmFzZWQgb24uICovXG4gIHJlcXVpcmVkQmFzZVNoYT86IHN0cmluZztcbiAgLyoqIFdoZXRoZXIgdGhlIHB1bGwgcmVxdWVzdCBjb21taXQgbWVzc2FnZSBmaXh1cC4gKi9cbiAgbmVlZHNDb21taXRNZXNzYWdlRml4dXA6IGJvb2xlYW47XG4gIC8qKiBXaGV0aGVyIHRoZSBwdWxsIHJlcXVlc3QgaGFzIGEgY2FyZXRha2VyIG5vdGUuICovXG4gIGhhc0NhcmV0YWtlck5vdGU6IGJvb2xlYW47XG59XG5cbi8qKlxuICogTG9hZHMgYW5kIHZhbGlkYXRlcyB0aGUgc3BlY2lmaWVkIHB1bGwgcmVxdWVzdCBhZ2FpbnN0IHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuICogSWYgdGhlIHB1bGwgcmVxdWVzdHMgZmFpbHMsIGEgcHVsbCByZXF1ZXN0IGZhaWx1cmUgaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkQW5kVmFsaWRhdGVQdWxsUmVxdWVzdChcbiAge2dpdCwgY29uZmlnfTogUHVsbFJlcXVlc3RNZXJnZVRhc2ssXG4gIHByTnVtYmVyOiBudW1iZXIsXG4gIGlnbm9yZU5vbkZhdGFsRmFpbHVyZXMgPSBmYWxzZSxcbik6IFByb21pc2U8UHVsbFJlcXVlc3QgfCBQdWxsUmVxdWVzdEZhaWx1cmU+IHtcbiAgY29uc3QgcHJEYXRhID0gYXdhaXQgZmV0Y2hQdWxsUmVxdWVzdEZyb21HaXRodWIoZ2l0LCBwck51bWJlcik7XG5cbiAgaWYgKHByRGF0YSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBQdWxsUmVxdWVzdEZhaWx1cmUubm90Rm91bmQoKTtcbiAgfVxuXG4gIGNvbnN0IGxhYmVscyA9IHByRGF0YS5sYWJlbHMubm9kZXMubWFwKChsKSA9PiBsLm5hbWUpO1xuXG4gIGlmICghbGFiZWxzLnNvbWUoKG5hbWUpID0+IG1hdGNoZXNQYXR0ZXJuKG5hbWUsIGNvbmZpZy5wdWxsUmVxdWVzdC5tZXJnZVJlYWR5TGFiZWwpKSkge1xuICAgIHJldHVybiBQdWxsUmVxdWVzdEZhaWx1cmUubm90TWVyZ2VSZWFkeSgpO1xuICB9XG4gIGlmICghbGFiZWxzLnNvbWUoKG5hbWUpID0+IG1hdGNoZXNQYXR0ZXJuKG5hbWUsIGNvbmZpZy5wdWxsUmVxdWVzdC5jbGFTaWduZWRMYWJlbCkpKSB7XG4gICAgcmV0dXJuIFB1bGxSZXF1ZXN0RmFpbHVyZS5jbGFVbnNpZ25lZCgpO1xuICB9XG5cbiAgLyoqIExpc3Qgb2YgcGFyc2VkIGNvbW1pdHMgZm9yIGFsbCBvZiB0aGUgY29tbWl0cyBpbiB0aGUgcHVsbCByZXF1ZXN0LiAqL1xuICBjb25zdCBjb21taXRzSW5QciA9IHByRGF0YS5jb21taXRzLm5vZGVzLm1hcCgobikgPT4gcGFyc2VDb21taXRNZXNzYWdlKG4uY29tbWl0Lm1lc3NhZ2UpKTtcbiAgY29uc3QgZ2l0aHViVGFyZ2V0QnJhbmNoID0gcHJEYXRhLmJhc2VSZWZOYW1lO1xuXG4gIGNvbnN0IHRhcmdldEJyYW5jaGVzID0gYXdhaXQgZ2V0VGFyZ2V0QnJhbmNoZXNGb3JQdWxsUmVxdWVzdChcbiAgICBnaXQuZ2l0aHViLFxuICAgIGNvbmZpZyxcbiAgICBsYWJlbHMsXG4gICAgZ2l0aHViVGFyZ2V0QnJhbmNoLFxuICAgIGNvbW1pdHNJblByLFxuICApO1xuXG4gIHRyeSB7XG4gICAgYXNzZXJ0UGVuZGluZ1N0YXRlKHByRGF0YSk7XG4gICAgYXNzZXJ0Q29ycmVjdEJyZWFraW5nQ2hhbmdlTGFiZWxpbmcoY29tbWl0c0luUHIsIGxhYmVscyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgdGhlIGVycm9yIGlzIGEgcHVsbCByZXF1ZXN0IGZhaWx1cmUsIHdlIHBhc3MgaXQgdGhyb3VnaCBncmFjZWZ1bGx5XG4gICAgLy8gYXMgdGhlIHRvb2wgZXhwZWN0cyBzdWNoIGZhaWx1cmVzIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIGZ1bmN0aW9uLlxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFB1bGxSZXF1ZXN0RmFpbHVyZSkge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8qKiBUaGUgY29tYmluZWQgc3RhdHVzIG9mIHRoZSBsYXRlc3QgY29tbWl0IGluIHRoZSBwdWxsIHJlcXVlc3QuICovXG4gIGNvbnN0IHN0YXRlID0gcHJEYXRhLmNvbW1pdHMubm9kZXMuc2xpY2UoLTEpWzBdLmNvbW1pdC5zdGF0dXMuc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ0ZBSUxVUkUnICYmICFpZ25vcmVOb25GYXRhbEZhaWx1cmVzKSB7XG4gICAgcmV0dXJuIFB1bGxSZXF1ZXN0RmFpbHVyZS5mYWlsaW5nQ2lKb2JzKCk7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnUEVORElORycgJiYgIWlnbm9yZU5vbkZhdGFsRmFpbHVyZXMpIHtcbiAgICByZXR1cm4gUHVsbFJlcXVlc3RGYWlsdXJlLnBlbmRpbmdDaUpvYnMoKTtcbiAgfVxuXG4gIGNvbnN0IHJlcXVpcmVkQmFzZVNoYSA9XG4gICAgY29uZmlnLnB1bGxSZXF1ZXN0LnJlcXVpcmVkQmFzZUNvbW1pdHMgJiZcbiAgICBjb25maWcucHVsbFJlcXVlc3QucmVxdWlyZWRCYXNlQ29tbWl0c1tnaXRodWJUYXJnZXRCcmFuY2hdO1xuICBjb25zdCBuZWVkc0NvbW1pdE1lc3NhZ2VGaXh1cCA9XG4gICAgISFjb25maWcucHVsbFJlcXVlc3QuY29tbWl0TWVzc2FnZUZpeHVwTGFiZWwgJiZcbiAgICBsYWJlbHMuc29tZSgobmFtZSkgPT4gbWF0Y2hlc1BhdHRlcm4obmFtZSwgY29uZmlnLnB1bGxSZXF1ZXN0LmNvbW1pdE1lc3NhZ2VGaXh1cExhYmVsKSk7XG4gIGNvbnN0IGhhc0NhcmV0YWtlck5vdGUgPVxuICAgICEhY29uZmlnLnB1bGxSZXF1ZXN0LmNhcmV0YWtlck5vdGVMYWJlbCAmJlxuICAgIGxhYmVscy5zb21lKChuYW1lKSA9PiBtYXRjaGVzUGF0dGVybihuYW1lLCBjb25maWcucHVsbFJlcXVlc3QuY2FyZXRha2VyTm90ZUxhYmVsISkpO1xuXG4gIHJldHVybiB7XG4gICAgdXJsOiBwckRhdGEudXJsLFxuICAgIHByTnVtYmVyLFxuICAgIGxhYmVscyxcbiAgICByZXF1aXJlZEJhc2VTaGEsXG4gICAgZ2l0aHViVGFyZ2V0QnJhbmNoLFxuICAgIG5lZWRzQ29tbWl0TWVzc2FnZUZpeHVwLFxuICAgIGhhc0NhcmV0YWtlck5vdGUsXG4gICAgdGFyZ2V0QnJhbmNoZXMsXG4gICAgdGl0bGU6IHByRGF0YS50aXRsZSxcbiAgICBjb21taXRDb3VudDogcHJEYXRhLmNvbW1pdHMudG90YWxDb3VudCxcbiAgfTtcbn1cblxuLyoqIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSByZXNvbHZlcyB0byBhIHB1bGwgcmVxdWVzdC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1B1bGxSZXF1ZXN0KHY6IFB1bGxSZXF1ZXN0RmFpbHVyZSB8IFB1bGxSZXF1ZXN0KTogdiBpcyBQdWxsUmVxdWVzdCB7XG4gIHJldHVybiAodiBhcyBQdWxsUmVxdWVzdCkudGFyZ2V0QnJhbmNoZXMgIT09IHVuZGVmaW5lZDtcbn1cbiJdfQ==