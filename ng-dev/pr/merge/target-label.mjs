"use strict";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBranchesFromTargetLabel = exports.getTargetLabelFromPullRequest = exports.InvalidTargetLabelError = exports.InvalidTargetBranchError = void 0;
const labels_1 = require("./defaults/labels");
const string_pattern_1 = require("./string-pattern");
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid branch is targeted.
 */
class InvalidTargetBranchError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetBranchError = InvalidTargetBranchError;
/**
 * Unique error that can be thrown in the merge configuration if an
 * invalid label has been applied to a pull request.
 */
class InvalidTargetLabelError {
    constructor(failureMessage) {
        this.failureMessage = failureMessage;
    }
}
exports.InvalidTargetLabelError = InvalidTargetLabelError;
/** Gets the target label from the specified pull request labels. */
async function getTargetLabelFromPullRequest(config, labels) {
    if (config.noTargetLabeling) {
        throw Error('This repository does not use target labels');
    }
    const targetLabels = await (0, labels_1.getTargetLabels)();
    /** List of discovered target labels for the PR. */
    const matches = [];
    for (const label of labels) {
        const match = targetLabels.find(({ pattern }) => (0, string_pattern_1.matchesPattern)(label, pattern));
        if (match !== undefined) {
            matches.push(match);
        }
    }
    if (matches.length === 1) {
        return matches[0];
    }
    if (matches.length === 0) {
        throw new InvalidTargetLabelError('Unable to determine target for the PR as it has no target label.');
    }
    throw new InvalidTargetLabelError('Unable to determine target for the PR as it has multiple target labels.');
}
exports.getTargetLabelFromPullRequest = getTargetLabelFromPullRequest;
/**
 * Gets the branches from the specified target label.
 *
 * @throws {InvalidTargetLabelError} Invalid label has been applied to pull request.
 * @throws {InvalidTargetBranchError} Invalid Github target branch has been selected.
 */
async function getBranchesFromTargetLabel(label, githubTargetBranch) {
    return typeof label.branches === 'function'
        ? await label.branches(githubTargetBranch)
        : await label.branches;
}
exports.getBranchesFromTargetLabel = getBranchesFromTargetLabel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFyZ2V0LWxhYmVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbmctZGV2L3ByL21lcmdlL3RhcmdldC1sYWJlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7OztHQU1HOzs7QUFHSCw4Q0FBa0Q7QUFDbEQscURBQWdEO0FBRWhEOzs7R0FHRztBQUNILE1BQWEsd0JBQXdCO0lBQ25DLFlBQW1CLGNBQXNCO1FBQXRCLG1CQUFjLEdBQWQsY0FBYyxDQUFRO0lBQUcsQ0FBQztDQUM5QztBQUZELDREQUVDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBYSx1QkFBdUI7SUFDbEMsWUFBbUIsY0FBc0I7UUFBdEIsbUJBQWMsR0FBZCxjQUFjLENBQVE7SUFBRyxDQUFDO0NBQzlDO0FBRkQsMERBRUM7QUFFRCxvRUFBb0U7QUFDN0QsS0FBSyxVQUFVLDZCQUE2QixDQUNqRCxNQUE2QyxFQUM3QyxNQUFnQjtJQUVoQixJQUFJLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtRQUMzQixNQUFNLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0tBQzNEO0lBRUQsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFBLHdCQUFlLEdBQUUsQ0FBQztJQUM3QyxtREFBbUQ7SUFDbkQsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBQ25CLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFO1FBQzFCLE1BQU0sS0FBSyxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFDLE9BQU8sRUFBQyxFQUFFLEVBQUUsQ0FBQyxJQUFBLCtCQUFjLEVBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDL0UsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDckI7S0FDRjtJQUNELElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDeEIsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbkI7SUFDRCxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3hCLE1BQU0sSUFBSSx1QkFBdUIsQ0FDL0Isa0VBQWtFLENBQ25FLENBQUM7S0FDSDtJQUNELE1BQU0sSUFBSSx1QkFBdUIsQ0FDL0IseUVBQXlFLENBQzFFLENBQUM7QUFDSixDQUFDO0FBNUJELHNFQTRCQztBQUVEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLDBCQUEwQixDQUM5QyxLQUFrQixFQUNsQixrQkFBMEI7SUFFMUIsT0FBTyxPQUFPLEtBQUssQ0FBQyxRQUFRLEtBQUssVUFBVTtRQUN6QyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDO1FBQzFDLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxRQUFRLENBQUM7QUFDM0IsQ0FBQztBQVBELGdFQU9DIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCB7TWVyZ2VDb25maWcsIFRhcmdldExhYmVsfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQge2dldFRhcmdldExhYmVsc30gZnJvbSAnLi9kZWZhdWx0cy9sYWJlbHMnO1xuaW1wb3J0IHttYXRjaGVzUGF0dGVybn0gZnJvbSAnLi9zdHJpbmctcGF0dGVybic7XG5cbi8qKlxuICogVW5pcXVlIGVycm9yIHRoYXQgY2FuIGJlIHRocm93biBpbiB0aGUgbWVyZ2UgY29uZmlndXJhdGlvbiBpZiBhblxuICogaW52YWxpZCBicmFuY2ggaXMgdGFyZ2V0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVGFyZ2V0QnJhbmNoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgZmFpbHVyZU1lc3NhZ2U6IHN0cmluZykge31cbn1cblxuLyoqXG4gKiBVbmlxdWUgZXJyb3IgdGhhdCBjYW4gYmUgdGhyb3duIGluIHRoZSBtZXJnZSBjb25maWd1cmF0aW9uIGlmIGFuXG4gKiBpbnZhbGlkIGxhYmVsIGhhcyBiZWVuIGFwcGxpZWQgdG8gYSBwdWxsIHJlcXVlc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWlsdXJlTWVzc2FnZTogc3RyaW5nKSB7fVxufVxuXG4vKiogR2V0cyB0aGUgdGFyZ2V0IGxhYmVsIGZyb20gdGhlIHNwZWNpZmllZCBwdWxsIHJlcXVlc3QgbGFiZWxzLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRhcmdldExhYmVsRnJvbVB1bGxSZXF1ZXN0KFxuICBjb25maWc6IFBpY2s8TWVyZ2VDb25maWcsICdub1RhcmdldExhYmVsaW5nJz4sXG4gIGxhYmVsczogc3RyaW5nW10sXG4pOiBQcm9taXNlPFRhcmdldExhYmVsPiB7XG4gIGlmIChjb25maWcubm9UYXJnZXRMYWJlbGluZykge1xuICAgIHRocm93IEVycm9yKCdUaGlzIHJlcG9zaXRvcnkgZG9lcyBub3QgdXNlIHRhcmdldCBsYWJlbHMnKTtcbiAgfVxuXG4gIGNvbnN0IHRhcmdldExhYmVscyA9IGF3YWl0IGdldFRhcmdldExhYmVscygpO1xuICAvKiogTGlzdCBvZiBkaXNjb3ZlcmVkIHRhcmdldCBsYWJlbHMgZm9yIHRoZSBQUi4gKi9cbiAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGxhYmVsIG9mIGxhYmVscykge1xuICAgIGNvbnN0IG1hdGNoID0gdGFyZ2V0TGFiZWxzLmZpbmQoKHtwYXR0ZXJufSkgPT4gbWF0Y2hlc1BhdHRlcm4obGFiZWwsIHBhdHRlcm4pKTtcbiAgICBpZiAobWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbMF07XG4gIH1cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUYXJnZXRMYWJlbEVycm9yKFxuICAgICAgJ1VuYWJsZSB0byBkZXRlcm1pbmUgdGFyZ2V0IGZvciB0aGUgUFIgYXMgaXQgaGFzIG5vIHRhcmdldCBsYWJlbC4nLFxuICAgICk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWRUYXJnZXRMYWJlbEVycm9yKFxuICAgICdVbmFibGUgdG8gZGV0ZXJtaW5lIHRhcmdldCBmb3IgdGhlIFBSIGFzIGl0IGhhcyBtdWx0aXBsZSB0YXJnZXQgbGFiZWxzLicsXG4gICk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYnJhbmNoZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHRhcmdldCBsYWJlbC5cbiAqXG4gKiBAdGhyb3dzIHtJbnZhbGlkVGFyZ2V0TGFiZWxFcnJvcn0gSW52YWxpZCBsYWJlbCBoYXMgYmVlbiBhcHBsaWVkIHRvIHB1bGwgcmVxdWVzdC5cbiAqIEB0aHJvd3Mge0ludmFsaWRUYXJnZXRCcmFuY2hFcnJvcn0gSW52YWxpZCBHaXRodWIgdGFyZ2V0IGJyYW5jaCBoYXMgYmVlbiBzZWxlY3RlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyYW5jaGVzRnJvbVRhcmdldExhYmVsKFxuICBsYWJlbDogVGFyZ2V0TGFiZWwsXG4gIGdpdGh1YlRhcmdldEJyYW5jaDogc3RyaW5nLFxuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICByZXR1cm4gdHlwZW9mIGxhYmVsLmJyYW5jaGVzID09PSAnZnVuY3Rpb24nXG4gICAgPyBhd2FpdCBsYWJlbC5icmFuY2hlcyhnaXRodWJUYXJnZXRCcmFuY2gpXG4gICAgOiBhd2FpdCBsYWJlbC5icmFuY2hlcztcbn1cbiJdfQ==