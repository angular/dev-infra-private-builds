"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PullApproveGroupArray = exports.PullApproveStringArray = exports.PullApproveGroupStateDependencyError = void 0;
const utils_1 = require("./utils");
class PullApproveGroupStateDependencyError extends Error {
    constructor(message) {
        super(message);
        // Set the prototype explicitly because in ES5, the prototype is accidentally
        // lost due to a limitation in down-leveling.
        // https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work.
        Object.setPrototypeOf(this, PullApproveGroupStateDependencyError.prototype);
        // Error names are displayed in their stack but can't be set in the constructor.
        this.name = PullApproveGroupStateDependencyError.name;
    }
}
exports.PullApproveGroupStateDependencyError = PullApproveGroupStateDependencyError;
/**
 * Superset of a native array. The superset provides methods which mimic the
 * list data structure used in PullApprove for files in conditions.
 */
class PullApproveStringArray extends Array {
    constructor(...elements) {
        super(...elements);
        // Set the prototype explicitly because in ES5, the prototype is accidentally
        // lost due to a limitation in down-leveling.
        // https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work.
        Object.setPrototypeOf(this, PullApproveStringArray.prototype);
    }
    /** Returns a new array which only includes files that match the given pattern. */
    include(pattern) {
        return new PullApproveStringArray(...this.filter((s) => (0, utils_1.getOrCreateGlob)(pattern).match(s)));
    }
    /** Returns a new array which only includes files that did not match the given pattern. */
    exclude(pattern) {
        return new PullApproveStringArray(...this.filter((s) => !(0, utils_1.getOrCreateGlob)(pattern).match(s)));
    }
}
exports.PullApproveStringArray = PullApproveStringArray;
/**
 * Superset of a native array. The superset provides methods which mimic the
 * list data structure used in PullApprove for groups in conditions.
 */
class PullApproveGroupArray extends Array {
    constructor(...elements) {
        super(...elements);
        // Set the prototype explicitly because in ES5, the prototype is accidentally
        // lost due to a limitation in down-leveling.
        // https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work.
        Object.setPrototypeOf(this, PullApproveGroupArray.prototype);
    }
    include(pattern) {
        return new PullApproveGroupArray(...this.filter((s) => s.groupName.match(pattern)));
    }
    /** Returns a new array which only includes files that did not match the given pattern. */
    exclude(pattern) {
        return new PullApproveGroupArray(...this.filter((s) => s.groupName.match(pattern)));
    }
    get pending() {
        throw new PullApproveGroupStateDependencyError();
    }
    get active() {
        throw new PullApproveGroupStateDependencyError();
    }
    get inactive() {
        throw new PullApproveGroupStateDependencyError();
    }
    get rejected() {
        throw new PullApproveGroupStateDependencyError();
    }
    get names() {
        return this.map((g) => g.groupName);
    }
}
exports.PullApproveGroupArray = PullApproveGroupArray;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVsbGFwcHJvdmVfYXJyYXlzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbmctZGV2L3B1bGxhcHByb3ZlL3B1bGxhcHByb3ZlX2FycmF5cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFRQSxtQ0FBd0M7QUFFeEMsTUFBYSxvQ0FBcUMsU0FBUSxLQUFLO0lBQzdELFlBQVksT0FBZ0I7UUFDMUIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2YsNkVBQTZFO1FBQzdFLDZDQUE2QztRQUM3QyxpSEFBaUg7UUFDakgsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsb0NBQW9DLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDNUUsZ0ZBQWdGO1FBQ2hGLElBQUksQ0FBQyxJQUFJLEdBQUcsb0NBQW9DLENBQUMsSUFBSSxDQUFDO0lBQ3hELENBQUM7Q0FDRjtBQVZELG9GQVVDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBYSxzQkFBdUIsU0FBUSxLQUFhO0lBQ3ZELFlBQVksR0FBRyxRQUFrQjtRQUMvQixLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQztRQUVuQiw2RUFBNkU7UUFDN0UsNkNBQTZDO1FBQzdDLGlIQUFpSDtRQUNqSCxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBQ0Qsa0ZBQWtGO0lBQ2xGLE9BQU8sQ0FBQyxPQUFlO1FBQ3JCLE9BQU8sSUFBSSxzQkFBc0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUEsdUJBQWUsRUFBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlGLENBQUM7SUFFRCwwRkFBMEY7SUFDMUYsT0FBTyxDQUFDLE9BQWU7UUFDckIsT0FBTyxJQUFJLHNCQUFzQixDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFBLHVCQUFlLEVBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvRixDQUFDO0NBQ0Y7QUFsQkQsd0RBa0JDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBYSxxQkFBc0IsU0FBUSxLQUF1QjtJQUNoRSxZQUFZLEdBQUcsUUFBNEI7UUFDekMsS0FBSyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUM7UUFFbkIsNkVBQTZFO1FBQzdFLDZDQUE2QztRQUM3QyxpSEFBaUg7UUFDakgsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUscUJBQXFCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVELE9BQU8sQ0FBQyxPQUFlO1FBQ3JCLE9BQU8sSUFBSSxxQkFBcUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RixDQUFDO0lBRUQsMEZBQTBGO0lBQzFGLE9BQU8sQ0FBQyxPQUFlO1FBQ3JCLE9BQU8sSUFBSSxxQkFBcUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RixDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1QsTUFBTSxJQUFJLG9DQUFvQyxFQUFFLENBQUM7SUFDbkQsQ0FBQztJQUVELElBQUksTUFBTTtRQUNSLE1BQU0sSUFBSSxvQ0FBb0MsRUFBRSxDQUFDO0lBQ25ELENBQUM7SUFFRCxJQUFJLFFBQVE7UUFDVixNQUFNLElBQUksb0NBQW9DLEVBQUUsQ0FBQztJQUNuRCxDQUFDO0lBRUQsSUFBSSxRQUFRO1FBQ1YsTUFBTSxJQUFJLG9DQUFvQyxFQUFFLENBQUM7SUFDbkQsQ0FBQztJQUVELElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7Q0FDRjtBQXRDRCxzREFzQ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7UHVsbEFwcHJvdmVHcm91cH0gZnJvbSAnLi9ncm91cCc7XG5pbXBvcnQge2dldE9yQ3JlYXRlR2xvYn0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBQdWxsQXBwcm92ZUdyb3VwU3RhdGVEZXBlbmRlbmN5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBleHBsaWNpdGx5IGJlY2F1c2UgaW4gRVM1LCB0aGUgcHJvdG90eXBlIGlzIGFjY2lkZW50YWxseVxuICAgIC8vIGxvc3QgZHVlIHRvIGEgbGltaXRhdGlvbiBpbiBkb3duLWxldmVsaW5nLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC93aWtpL0ZBUSN3aHktZG9lc250LWV4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLXdvcmsuXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFB1bGxBcHByb3ZlR3JvdXBTdGF0ZURlcGVuZGVuY3lFcnJvci5wcm90b3R5cGUpO1xuICAgIC8vIEVycm9yIG5hbWVzIGFyZSBkaXNwbGF5ZWQgaW4gdGhlaXIgc3RhY2sgYnV0IGNhbid0IGJlIHNldCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgdGhpcy5uYW1lID0gUHVsbEFwcHJvdmVHcm91cFN0YXRlRGVwZW5kZW5jeUVycm9yLm5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBTdXBlcnNldCBvZiBhIG5hdGl2ZSBhcnJheS4gVGhlIHN1cGVyc2V0IHByb3ZpZGVzIG1ldGhvZHMgd2hpY2ggbWltaWMgdGhlXG4gKiBsaXN0IGRhdGEgc3RydWN0dXJlIHVzZWQgaW4gUHVsbEFwcHJvdmUgZm9yIGZpbGVzIGluIGNvbmRpdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQdWxsQXBwcm92ZVN0cmluZ0FycmF5IGV4dGVuZHMgQXJyYXk8c3RyaW5nPiB7XG4gIGNvbnN0cnVjdG9yKC4uLmVsZW1lbnRzOiBzdHJpbmdbXSkge1xuICAgIHN1cGVyKC4uLmVsZW1lbnRzKTtcblxuICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGV4cGxpY2l0bHkgYmVjYXVzZSBpbiBFUzUsIHRoZSBwcm90b3R5cGUgaXMgYWNjaWRlbnRhbGx5XG4gICAgLy8gbG9zdCBkdWUgdG8gYSBsaW1pdGF0aW9uIGluIGRvd24tbGV2ZWxpbmcuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3dpa2kvRkFRI3doeS1kb2VzbnQtZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtd29yay5cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUHVsbEFwcHJvdmVTdHJpbmdBcnJheS5wcm90b3R5cGUpO1xuICB9XG4gIC8qKiBSZXR1cm5zIGEgbmV3IGFycmF5IHdoaWNoIG9ubHkgaW5jbHVkZXMgZmlsZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0dGVybi4gKi9cbiAgaW5jbHVkZShwYXR0ZXJuOiBzdHJpbmcpOiBQdWxsQXBwcm92ZVN0cmluZ0FycmF5IHtcbiAgICByZXR1cm4gbmV3IFB1bGxBcHByb3ZlU3RyaW5nQXJyYXkoLi4udGhpcy5maWx0ZXIoKHMpID0+IGdldE9yQ3JlYXRlR2xvYihwYXR0ZXJuKS5tYXRjaChzKSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSBuZXcgYXJyYXkgd2hpY2ggb25seSBpbmNsdWRlcyBmaWxlcyB0aGF0IGRpZCBub3QgbWF0Y2ggdGhlIGdpdmVuIHBhdHRlcm4uICovXG4gIGV4Y2x1ZGUocGF0dGVybjogc3RyaW5nKTogUHVsbEFwcHJvdmVTdHJpbmdBcnJheSB7XG4gICAgcmV0dXJuIG5ldyBQdWxsQXBwcm92ZVN0cmluZ0FycmF5KC4uLnRoaXMuZmlsdGVyKChzKSA9PiAhZ2V0T3JDcmVhdGVHbG9iKHBhdHRlcm4pLm1hdGNoKHMpKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTdXBlcnNldCBvZiBhIG5hdGl2ZSBhcnJheS4gVGhlIHN1cGVyc2V0IHByb3ZpZGVzIG1ldGhvZHMgd2hpY2ggbWltaWMgdGhlXG4gKiBsaXN0IGRhdGEgc3RydWN0dXJlIHVzZWQgaW4gUHVsbEFwcHJvdmUgZm9yIGdyb3VwcyBpbiBjb25kaXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgUHVsbEFwcHJvdmVHcm91cEFycmF5IGV4dGVuZHMgQXJyYXk8UHVsbEFwcHJvdmVHcm91cD4ge1xuICBjb25zdHJ1Y3RvciguLi5lbGVtZW50czogUHVsbEFwcHJvdmVHcm91cFtdKSB7XG4gICAgc3VwZXIoLi4uZWxlbWVudHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgZXhwbGljaXRseSBiZWNhdXNlIGluIEVTNSwgdGhlIHByb3RvdHlwZSBpcyBhY2NpZGVudGFsbHlcbiAgICAvLyBsb3N0IGR1ZSB0byBhIGxpbWl0YXRpb24gaW4gZG93bi1sZXZlbGluZy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvd2lraS9GQVEjd2h5LWRvZXNudC1leHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC13b3JrLlxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBQdWxsQXBwcm92ZUdyb3VwQXJyYXkucHJvdG90eXBlKTtcbiAgfVxuXG4gIGluY2x1ZGUocGF0dGVybjogc3RyaW5nKTogUHVsbEFwcHJvdmVHcm91cEFycmF5IHtcbiAgICByZXR1cm4gbmV3IFB1bGxBcHByb3ZlR3JvdXBBcnJheSguLi50aGlzLmZpbHRlcigocykgPT4gcy5ncm91cE5hbWUubWF0Y2gocGF0dGVybikpKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGEgbmV3IGFycmF5IHdoaWNoIG9ubHkgaW5jbHVkZXMgZmlsZXMgdGhhdCBkaWQgbm90IG1hdGNoIHRoZSBnaXZlbiBwYXR0ZXJuLiAqL1xuICBleGNsdWRlKHBhdHRlcm46IHN0cmluZyk6IFB1bGxBcHByb3ZlR3JvdXBBcnJheSB7XG4gICAgcmV0dXJuIG5ldyBQdWxsQXBwcm92ZUdyb3VwQXJyYXkoLi4udGhpcy5maWx0ZXIoKHMpID0+IHMuZ3JvdXBOYW1lLm1hdGNoKHBhdHRlcm4pKSk7XG4gIH1cblxuICBnZXQgcGVuZGluZygpIHtcbiAgICB0aHJvdyBuZXcgUHVsbEFwcHJvdmVHcm91cFN0YXRlRGVwZW5kZW5jeUVycm9yKCk7XG4gIH1cblxuICBnZXQgYWN0aXZlKCkge1xuICAgIHRocm93IG5ldyBQdWxsQXBwcm92ZUdyb3VwU3RhdGVEZXBlbmRlbmN5RXJyb3IoKTtcbiAgfVxuXG4gIGdldCBpbmFjdGl2ZSgpIHtcbiAgICB0aHJvdyBuZXcgUHVsbEFwcHJvdmVHcm91cFN0YXRlRGVwZW5kZW5jeUVycm9yKCk7XG4gIH1cblxuICBnZXQgcmVqZWN0ZWQoKSB7XG4gICAgdGhyb3cgbmV3IFB1bGxBcHByb3ZlR3JvdXBTdGF0ZURlcGVuZGVuY3lFcnJvcigpO1xuICB9XG5cbiAgZ2V0IG5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLm1hcCgoZykgPT4gZy5ncm91cE5hbWUpO1xuICB9XG59XG4iXX0=